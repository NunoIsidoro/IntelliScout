{"version":3,"file":"cryptographyClient.js","sourceRoot":"","sources":["../../../src/cryptographyClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  JsonWebKey,\n  GetKeyOptions,\n  CryptographyOptions,\n  KeyVaultKey,\n  EncryptionAlgorithm,\n  CryptographyClientOptions,\n  LATEST_API_VERSION\n} from \"./keysModels\";\nimport {\n  TokenCredential,\n  isNode,\n  createPipelineFromOptions,\n  isTokenCredential,\n  RequestOptionsBase,\n  signingPolicy,\n  operationOptionsToRequestOptionsBase\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\nimport { parseKeyvaultIdentifier } from \"./generated/utils\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\nimport { createHash as cryptoCreateHash, createVerify, publicEncrypt } from \"crypto\";\nimport * as constants from \"constants\";\n\n/**\n * A client used to perform cryptographic operations with Azure Key Vault keys.\n */\nexport class CryptographyClient {\n  /**\n   * @internal\n   * @ignore\n   * Retrieves the {@link JsonWebKey} from the Key Vault.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKey();\n   * ```\n   * @param {GetKeyOptions} [options] Options for retrieving key.\n   */\n  private async getKey(options: GetKeyOptions = {}): Promise<JsonWebKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getKey\", requestOptions);\n\n    if (typeof this.key === \"string\") {\n      if (!this.name || this.name === \"\") {\n        throw new Error(\"getKey requires a key with a name\");\n      }\n      const key = await this.client.getKey(\n        this.vaultUrl,\n        this.name,\n        options && options.version ? options.version : this.version ? this.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n      return key.key! as JsonWebKey;\n    } else {\n      return this.key;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param {EncryptionAlgorithm} algorithm The algorithm to use.\n   * @param {Uint8Array} plaintext The text to encrypt.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options: EncryptOptions = {}\n  ): Promise<EncryptResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"encrypt\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RSA1_5\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"encrypt\")) {\n              span.end();\n              throw new Error(\"Key does not support the encrypt operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const padded: any = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };\n            const encrypted = publicEncrypt(padded, Buffer.from(plaintext));\n            return { result: encrypted, algorithm, keyID: this.key.kid };\n          }\n          case \"RSA-OAEP\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"encrypt\")) {\n              span.end();\n              throw new Error(\"Key does not support the encrypt operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const encrypted = publicEncrypt(keyPEM, Buffer.from(plaintext));\n            return { result: encrypted, algorithm, keyID: this.key.kid };\n          }\n        }\n      }\n    }\n\n    // Default to the service\n    let result;\n    try {\n      result = await this.client.encrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        plaintext,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   * @param {EncryptionAlgorithm} algorithm The algorithm to use.\n   * @param {Uint8Array} ciphertext The text to decrypt.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n\n  public async decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options: DecryptOptions = {}\n  ): Promise<DecryptResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"decrypt\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.decrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        ciphertext,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, keyID: this.getKeyID(), algorithm };\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.\n   * @param {Uint8Array} key The key to wrap.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"wrapKey\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RSA1_5\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"wrapKey\")) {\n              span.end();\n              throw new Error(\"Key does not support the wrapKey operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const padded: any = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };\n            const encrypted = publicEncrypt(padded, Buffer.from(key));\n            return { result: encrypted, algorithm, keyID: this.getKeyID() };\n          }\n          case \"RSA-OAEP\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"wrapKey\")) {\n              span.end();\n              throw new Error(\"Key does not support the wrapKey operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const encrypted = publicEncrypt(keyPEM, Buffer.from(key));\n            return { result: encrypted, algorithm, keyID: this.getKeyID() };\n          }\n        }\n      }\n    }\n\n    // Default to the service\n    let result;\n    try {\n      result = await this.client.wrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        key,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.\n   * @param {Uint8Array} encryptedKey The encrypted key to unwrap.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"unwrapKey\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.unwrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        encryptedKey,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.\n   * @param {Uint8Array} digest The digest of the data to sign.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"sign\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.\n   * @param {Uint8Array} digest The digest to verify.\n   * @param {Uint8Array} signature The signature to verify the digest against.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"verify\", requestOptions);\n\n    let response;\n    try {\n      response = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: response.value ? response.value : false, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.\n   * @param {Uint8Array} data The data to sign.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"signData\", requestOptions);\n\n    let digest;\n    switch (algorithm) {\n      case \"ES256\":\n      case \"ES256K\":\n      case \"PS256\":\n      case \"RS256\":\n        {\n          digest = await createHash(\"sha256\", data);\n        }\n        break;\n      case \"ES384\":\n      case \"PS384\":\n      case \"RS384\":\n        {\n          digest = await createHash(\"sha384\", data);\n        }\n        break;\n      case \"ES512\":\n      case \"PS512\":\n      case \"RS512\":\n        {\n          digest = await createHash(\"sha512\", data);\n        }\n        break;\n      default: {\n        throw new Error(\"Unsupported signature algorithm\");\n      }\n    }\n\n    let result;\n    try {\n      result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.\n   * @param {Uint8Array} data The signed block of data to verify.\n   * @param {Uint8Array} signature The signature to verify the block against.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"verifyData\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RS256\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA256\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n          case \"RS384\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA384\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n          case \"RS512\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA512\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n        }\n      }\n    }\n\n    let digest: Buffer;\n    switch (algorithm) {\n      case \"ES256\":\n      case \"ES256K\":\n      case \"PS256\":\n      case \"RS256\":\n        {\n          digest = await createHash(\"sha256\", data);\n        }\n        break;\n      case \"ES384\":\n      case \"PS384\":\n      case \"RS384\":\n        {\n          digest = await createHash(\"sha384\", data);\n        }\n        break;\n      case \"ES512\":\n      case \"PS512\":\n      case \"RS512\":\n        {\n          digest = await createHash(\"sha512\", data);\n        }\n        break;\n      default: {\n        throw new Error(\"Unsupported signature algorithm\");\n      }\n    }\n\n    let result;\n    try {\n      result = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.value!, keyID: this.getKeyID() };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Attempts to fetch the key from the service.\n   */\n  private async fetchFullKeyIfPossible(): Promise<void> {\n    if (!this.hasTriedToGetKey) {\n      try {\n        this.key = await this.getKey();\n      } catch {\n        // Nothing to do here.\n      }\n      this.hasTriedToGetKey = true;\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.kid;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor, it can be either a string with the URL of a KeyVault Key, or an already parsed {@link JsonWebKey}.\n   */\n  private key: string | JsonWebKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Has the client tried to fetch the full key yet\n   */\n  private hasTriedToGetKey: boolean;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.\n   *                                                         Omit this parameter to use the default pipeline configuration.\n   * @memberof CryptographyClient\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n\n    let parsed;\n    if (typeof key === \"string\") {\n      this.key = key;\n      parsed = parseKeyvaultIdentifier(\"keys\", this.key);\n      this.hasTriedToGetKey = false;\n    } else if (key.key) {\n      this.key = key.key;\n      parsed = parseKeyvaultIdentifier(\"keys\", this.key.kid!);\n      this.hasTriedToGetKey = true;\n    } else {\n      throw new Error(\n        \"The provided key is malformed as it does not have a value for the `key` property.\"\n      );\n    }\n\n    if (parsed.name === \"\") {\n      throw new Error(\"Could not find 'name' of key in key URL\");\n    }\n\n    if (!parsed.version || parsed.version === \"\") {\n      throw new Error(\"Could not find 'version' of key in key URL\");\n    }\n\n    if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n      throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n    }\n\n    this.vaultUrl = parsed.vaultUrl;\n    this.name = parsed.name;\n    this.version = parsed.version;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user.\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions?: RequestOptionsBase): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(\n      `CryptographyClient ${methodName}`,\n      requestOptions && requestOptions.spanOptions\n    );\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Encodes a length of a packet in DER format\n */\nfunction encodeLength(length: number): Uint8Array {\n  if (length <= 127) {\n    return Uint8Array.of(length);\n  } else if (length < 256) {\n    return Uint8Array.of(0x81, length);\n  } else if (length < 65536) {\n    return Uint8Array.of(0x82, length >> 8, length & 0xff);\n  } else {\n    throw new Error(\"Unsupported length to encode\");\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Encodes a buffer for DER, as sets the id to the given id\n */\nfunction encodeBuffer(buffer: Uint8Array, bufferId: number): Uint8Array {\n  if (buffer.length === 0) {\n    return buffer;\n  }\n\n  let result = new Uint8Array(buffer);\n\n  // If the high bit is set, prepend a 0\n  if ((result[0] & 0x80) === 0x80) {\n    const array = new Uint8Array(result.length + 1);\n    array[0] = 0;\n    array.set(result, 1);\n    result = array;\n  }\n\n  // Prepend the DER header for this buffer\n  const encodedLength = encodeLength(result.length);\n\n  const totalLength = 1 + encodedLength.length + result.length;\n\n  const outputBuffer = new Uint8Array(totalLength);\n  outputBuffer[0] = bufferId;\n  outputBuffer.set(encodedLength, 1);\n  outputBuffer.set(result, 1 + encodedLength.length);\n\n  return outputBuffer;\n}\n\n/**\n * @internal\n * @ignore\n * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER\n * that is then encoded as a PEM.\n */\nexport function convertJWKtoPEM(key: JsonWebKey): string {\n  if (!key.n || !key.e) {\n    throw new Error(\"Unsupported key format for local operations\");\n  }\n  const encoded_n = encodeBuffer(key.n, 0x2); // INTEGER\n  const encoded_e = encodeBuffer(key.e, 0x2); // INTEGER\n\n  const encoded_ne = new Uint8Array(encoded_n.length + encoded_e.length);\n  encoded_ne.set(encoded_n, 0);\n  encoded_ne.set(encoded_e, encoded_n.length);\n\n  const full_encoded = encodeBuffer(encoded_ne, 0x30); // SEQUENCE\n\n  const buffer = Buffer.from(full_encoded).toString(\"base64\");\n\n  const beginBanner = \"-----BEGIN RSA PUBLIC KEY-----\\n\";\n  const endBanner = \"-----END RSA PUBLIC KEY-----\";\n\n  /*\n   Fill in the PEM with 64 character lines as per RFC:\n\n   \"To represent the encapsulated text of a PEM message, the encoding\n   function's output is delimited into text lines (using local\n   conventions), with each line except the last containing exactly 64\n   printable characters and the final line containing 64 or fewer\n   printable characters.\"\n  */\n  let outputString = beginBanner;\n  const lines = buffer.match(/.{1,64}/g);\n\n  if (lines) {\n    for (const line of lines) {\n      outputString += line;\n      outputString += \"\\n\";\n    }\n  } else {\n    throw new Error(\"Could not create correct PEM\");\n  }\n  outputString += endBanner;\n\n  return outputString;\n}\n\n/**\n * @internal\n * @ignore\n * Use the platform-local hashing functionality\n */\nasync function createHash(algorithm: string, data: Uint8Array): Promise<Buffer> {\n  if (isNode) {\n    const hash = cryptoCreateHash(algorithm);\n    hash.update(Buffer.from(data));\n    const digest = hash.digest();\n    return digest;\n  } else {\n    if (window && window.crypto && window.crypto.subtle) {\n      return Buffer.from(await window.crypto.subtle.digest(algorithm, Buffer.from(data)));\n    } else {\n      throw new Error(\"Browser does not support cryptography functions\");\n    }\n  }\n}\n\n/**\n * Supported algorithms for key wrapping/unwrapping\n */\nexport type KeyWrapAlgorithm = \"RSA-OAEP\" | \"RSA-OAEP-256\" | \"RSA1_5\";\n\n/**\n * Defines values for SignatureAlgorithm.\n * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512',\n * 'ES256', 'ES384', 'ES512', 'ES256K'\n * @readonly\n * @enum {string}\n */\nexport type SignatureAlgorithm =\n  | \"PS256\"\n  | \"PS384\"\n  | \"PS512\"\n  | \"RS256\"\n  | \"RS384\"\n  | \"RS512\"\n  | \"ES256\"\n  | \"ES384\"\n  | \"ES512\"\n  | \"ES256K\";\n\n/**\n * Options for {@link encrypt}.\n */\nexport interface EncryptOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link decrypt}.\n */\nexport interface DecryptOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link sign}.\n */\nexport interface SignOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link verify}.\n */\nexport interface VerifyOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link wrapKey}.\n */\nexport interface WrapKeyOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link unwrapKey}.\n */\nexport interface UnwrapKeyOptions extends CryptographyOptions {}\n\n/**\n * Result of the {@link decrypt} operation.\n */\nexport interface DecryptResult {\n  /**\n   * Result of the {@link decrypt} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to decrypt the encrypted data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to decrypt the encrypted data.\n   */\n  algorithm: EncryptionAlgorithm;\n}\n\n/**\n * Result of the {@link encrypt} operation.\n */\nexport interface EncryptResult {\n  /**\n   * Result of the {@link encrypt} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The {@link EncryptionAlgorithm} used to encrypt the data.\n   */\n  algorithm: EncryptionAlgorithm;\n  /**\n   * The ID of the KeyVault Key used to encrypt the data.\n   */\n  keyID?: string;\n}\n\n/**\n * Result of the {@link sign} operation.\n */\nexport interface SignResult {\n  /**\n   * Result of the {@link sign} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to sign the data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to sign the data.\n   */\n  algorithm: SignatureAlgorithm;\n}\n\n/**\n * Result of the {@link verify} operation.\n */\nexport interface VerifyResult {\n  /**\n   * Result of the {@link verify} operation in bytes.\n   */\n  result: boolean;\n  /**\n   * The ID of the KeyVault Key used to verify the data.\n   */\n  keyID?: string;\n}\n\n/**\n * Result of the {@link wrap} operation.\n */\nexport interface WrapResult {\n  /**\n   * Result of the {@link wrap} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to wrap the data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to wrap the data.\n   */\n  algorithm: KeyWrapAlgorithm;\n}\n\n/**\n * Result of the {@link unwrap} operation.\n */\nexport interface UnwrapResult {\n  /**\n   * Result of the {@link unwrap} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to unwrap the data.\n   */\n  keyID?: string;\n}\n"]}