{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  PipelineOptions,\n  RequestOptionsBase,\n  TokenCredential,\n  createPipelineFromOptions,\n  isTokenCredential,\n  operationOptionsToRequestOptionsBase,\n  signingPolicy\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  BackupKeyResponse,\n  CreateKeyResponse,\n  DeleteKeyResponse,\n  DeletedKeyBundle,\n  DeletionRecoveryLevel,\n  GetDeletedKeyResponse,\n  GetKeyResponse,\n  ImportKeyResponse,\n  KeyBundle,\n  KeyItem,\n  KeyVaultClientGetKeysOptionalParams,\n  RecoverDeletedKeyResponse,\n  RestoreKeyResponse,\n  UpdateKeyResponse\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteKeyPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedKeyPoller } from \"./lro/recover/poller\";\n\nimport {\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyOptions,\n  DeletedKey,\n  DeleteKeyOptions,\n  EncryptionAlgorithm,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyClientInterface,\n  KeyCurveName,\n  KeyOperation,\n  KeyPollerOptions,\n  KeyType,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  KeyVaultKey,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PurgeDeletedKeyOptions,\n  RecoverDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  UpdateKeyPropertiesOptions,\n  KeyClientOptions,\n  LATEST_API_VERSION,\n  CryptographyClientOptions\n} from \"./keysModels\";\nimport { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from \"./generated/utils\";\n\nimport {\n  CryptographyClient,\n  DecryptOptions,\n  DecryptResult,\n  EncryptOptions,\n  EncryptResult,\n  SignatureAlgorithm,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult\n} from \"./cryptographyClient\";\n\nexport {\n  CryptographyClientOptions,\n  KeyClientOptions,\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyClient,\n  CryptographyOptions,\n  DecryptOptions,\n  DecryptResult,\n  DeletedKey,\n  DeletionRecoveryLevel,\n  EncryptOptions,\n  EncryptResult,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyCurveName,\n  EncryptionAlgorithm,\n  KeyOperation,\n  KeyType,\n  KeyPollerOptions,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  SignatureAlgorithm,\n  KeyVaultKey,\n  KeyWrapAlgorithm,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PageSettings,\n  PagedAsyncIterableIterator,\n  PipelineOptions,\n  PollOperationState,\n  PollerLike,\n  PurgeDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  UpdateKeyPropertiesOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n  logger\n};\n\n/**\n * The KeyClient provides methods to manage {@link KeyVaultKey} in the\n * Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultKeys. The\n * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key\n * Vault.\n */\nexport class KeyClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * @internal\n   * @ignore\n   * A self reference that bypasses private methods, for the pollers.\n   */\n  private readonly pollerClient: KeyClientInterface = {\n    recoverDeletedKey: this.recoverDeletedKey.bind(this),\n    getKey: this.getKey.bind(this),\n    deleteKey: this.deleteKey.bind(this),\n    getDeletedKey: this.getDeletedKey.bind(this)\n  };\n\n  /**\n   * Creates an instance of KeyClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new KeyClient(vaultUrl, credentials);\n   * ```\n   * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.\n   * @memberof KeyClient\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: KeyClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a delete request for the given KeyVault Key's name to the KeyVault service.\n   * Since the KeyVault Key won't be immediately deleted, we have {@link beginDeleteKey}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {DeleteKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async deleteKey(name: string, options: DeleteKeyOptions = {}): Promise<DeletedKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"deleteKey\", requestOptions);\n\n    let response: DeleteKeyResponse;\n    try {\n      response = await this.client.deleteKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a request to recover a deleted KeyVault Key based on the given name.\n   * Since the KeyVault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async recoverDeletedKey(\n    name: string,\n    options: RecoverDeletedKeyOptions = {}\n  ): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"recoverDeletedKey\", requestOptions);\n\n    let response: RecoverDeletedKeyResponse;\n    try {\n      response = await this.client.recoverDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Create an elliptic-curve key:\n   * let result = await client.createKey(\"MyKey\", \"EC\");\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {KeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.\n   * @param {CreateKeyOptions} [options] The optional parameters.\n   */\n  public async createKey(\n    name: string,\n    keyType: KeyType,\n    options?: CreateKeyOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          keyType,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, keyType, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createEcKey(\"MyKey\", { curve: \"P-256\" });\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {CreateEcKeyOptions} [options] The optional parameters.\n   */\n  public async createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createEcKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          options.hsm ? \"EC-HSM\" : \"EC\",\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, \"EC\", options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createRsaKey(\"MyKey\", { keySize: 2048 });\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {CreateRsaKeyOptions} [options] The optional parameters.\n   */\n  public async createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createRsaKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          options.hsm ? \"RSA-HSM\" : \"RSA\",\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, \"RSA\", options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Key contents in myKeyContents\n   * let result = await client.importKey(\"MyKey\", myKeyContents);\n   * ```\n   * @summary Imports an externally created key, stores it, and returns key parameters and properties\n   * to the client.\n   * @param {string} name Name for the imported key.\n   * @param {JsonWebKey} key The JSON web key.\n   * @param {ImportKeyOptions} [options] The optional parameters.\n   */\n  public async importKey(\n    name: string,\n    key: JsonWebKey,\n    options?: ImportKeyOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const {\n        enabled,\n        notBefore,\n        expiresOn: expires,\n        hardwareProtected: hsm,\n        ...remainingOptions\n      } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          hsm\n        }\n      };\n\n      const span = this.createSpan(\"importKey\", unflattenedOptions);\n\n      let response: ImportKeyResponse;\n      try {\n        response = await this.client.importKey(\n          this.vaultUrl,\n          name,\n          key,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.importKey(this.vaultUrl, name, key, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.\n   *\n   * This operation requires the keys/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const poller = await client.beginDeleteKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginDeleteKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedKey = await poller.pollUntilDone();\n   * console.log(deletedKey);\n   * ```\n   * @summary Deletes a key from a specified key vault.\n   * @param {string} name The name of the key.\n   * @param {BeginDeleteKeyOptions} [options] The optional parameters.\n   */\n  public async beginDeleteKey(\n    name: string,\n    options: BeginDeleteKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const poller = new DeleteKeyPoller({\n      name,\n      client: this.pollerClient,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      requestOptions\n    });\n\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n\n    return poller;\n  }\n\n  /**\n   * The updateKeyProperties method changes specified properties of an existing stored key. Properties that\n   * are not specified in the request are left unchanged. The value of a key itself cannot be\n   * changed. This operation requires the keys/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let keyName = \"MyKey\";\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(keyName);\n   * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });\n   * ```\n   * @summary Updates the properties associated with a specified key in a given key vault.\n   * @param {string} name The name of the key.\n   * @param {string} keyVersion The version of the key.\n   * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.\n   */\n  public async updateKeyProperties(\n    name: string,\n    keyVersion: string,\n    options?: UpdateKeyPropertiesOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"updateKeyProperties\", unflattenedOptions);\n\n      let response: UpdateKeyResponse;\n\n      try {\n        response = await this.client.updateKey(\n          this.vaultUrl,\n          name,\n          keyVersion,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.updateKey(this.vaultUrl, name, keyVersion, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(\"MyKey\");\n   * ```\n   * @summary Get a specified key from a given key vault.\n   * @param {string} name The name of the key.\n   * @param {GetKeyOptions} [options] The optional parameters.\n   */\n  public async getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getKey\", requestOptions);\n\n    let response: GetKeyResponse;\n    try {\n      response = await this.client.getKey(\n        this.vaultUrl,\n        name,\n        options && options.version ? options.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getDeletedKey(\"MyDeletedKey\");\n   * ```\n   * @summary Gets the specified deleted key.\n   * @param {string} name The name of the key.\n   * @param {GetDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async getDeletedKey(\n    name: string,\n    options: GetDeletedKeyOptions = {}\n  ): Promise<DeletedKey> {\n    const responseOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getDeletedKey\", responseOptions);\n\n    let response: GetDeletedKeyResponse;\n    try {\n      response = await this.client.getDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, responseOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The purge deleted key operation removes the key permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the keys/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\")\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedKey(\"MyKey\");\n   * ```\n   * @summary Permanently deletes the specified key.\n   * @param name The name of the key.\n   * @param {PurgeDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async purgeDeletedKey(name: string, options: PurgeDeletedKeyOptions = {}): Promise<void> {\n    const responseOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"purgeDeletedKey\", responseOptions);\n\n    try {\n      await this.client.purgeDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, responseOptions)\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.\n   *\n   * This operation requires the keys/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\");\n   * await deletePoller.pollUntilDone();\n   * const poller = await client.beginRecoverDeletedKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginRecoverDeletedKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const key = await poller.pollUntilDone();\n   * console.log(key);\n   * ```\n   * @summary Recovers the deleted key to the latest version.\n   * @param name The name of the deleted key.\n   * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async beginRecoverDeletedKey(\n    name: string,\n    options: BeginRecoverDeletedKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    const poller = new RecoverDeletedKeyPoller({\n      name,\n      client: this.pollerClient,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      requestOptions: requestOptions\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified key be downloaded to the client. All versions of the\n   * key will be downloaded. This operation requires the keys/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * ```\n   * @summary Backs up the specified key.\n   * @param {string} name The name of the key.\n   * @param {BackupKeyOptions} [options] The optional parameters.\n   */\n  public async backupKey(\n    name: string,\n    options: BackupKeyOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"backupKey\", requestOptions);\n\n    let response: BackupKeyResponse;\n    try {\n      response = await this.client.backupKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return response.value;\n  }\n\n  /**\n   * Restores a backed up key, and all its versions, to a vault. This operation requires the\n   * keys/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * // ...\n   * let key = await client.restoreKeyBackup(backupContents);\n   * ```\n   * @summary Restores a backed up key to a vault.\n   * @param {Uint8Array} backup The backup blob associated with a key bundle.\n   * @param {RestoreKeyBackupOptions} [options] The optional parameters.\n   */\n  public async restoreKeyBackup(\n    backup: Uint8Array,\n    options: RestoreKeyBackupOptions = {}\n  ): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"restoreKeyBackup\", requestOptions);\n\n    let response: RestoreKeyResponse;\n    try {\n      response = await this.client.restoreKey(\n        this.vaultUrl,\n        backup,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfKeyVersions}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsPage(\n    name: string,\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getKeyVersions(\n        this.vaultUrl,\n        name,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getKeyVersions(\n        continuationState.continuationToken,\n        name,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsAll(\n    name: string,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeyVersionsPage(name, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided\n   * in the response. This operation requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeyVersions(\"MyKey\")) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key version: \", key);\n   * }\n   * ```\n   * @param {string} name Name of the key to fetch versions for\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfKeyVersions(\n    name: string,\n    options: ListPropertiesOfKeyVersionsOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfKeyVersions\", requestOptions);\n    const updatedOptions: ListPropertiesOfKeyVersionsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfKeyVersionsAll(name, updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeyVersionsPage(name, settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfKeys}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysPage(\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getKeys(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getKeys(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.\n   * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysAll(\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeys()) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key: \", key);\n   * }\n   * ```\n   * @summary List all keys in the vault\n   * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfKeys(\n    options: ListPropertiesOfKeysOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfKeys\", requestOptions);\n    const updatedOptions: ListPropertiesOfKeysOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfKeysAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeysPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listDeletedKeys}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysPage(\n    continuationState: PageSettings,\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getDeletedKeys(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getDeletedKeyFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getDeletedKeys(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getDeletedKeyFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listDeletedKeys}.\n   * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysAll(\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey> {\n    const f = {};\n\n    for await (const page of this.listDeletedKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const deletedKey of client.listDeletedKeys()) {\n   *   console.log(\"deleted key: \", deletedKey);\n   * }\n   * ```\n   * @summary List all keys in the vault\n   * @param {ListDeletedKeysOptions} [options] The optional parameters.\n   */\n  public listDeletedKeys(\n    options: ListDeletedKeysOptions = {}\n  ): PagedAsyncIterableIterator<DeletedKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listDeletedKeys\", requestOptions);\n\n    const updatedOptions: ListDeletedKeysOptions = {\n      ...options,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listDeletedKeysAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedKeysPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.\n   */\n  private getKeyFromKeyBundle(bundle: KeyBundle | DeletedKeyBundle): KeyVaultKey {\n    const keyBundle = bundle as KeyBundle;\n    const deletedKeyBundle = bundle as DeletedKeyBundle;\n\n    const parsedId = parseKeyvaultEntityIdentifier(\n      \"keys\",\n      keyBundle.key ? keyBundle.key.kid : undefined\n    );\n\n    const attributes: any = keyBundle.attributes || {};\n    delete keyBundle.attributes;\n\n    const resultObject: KeyVaultKey & DeletedKey = {\n      key: keyBundle.key as JsonWebKey,\n      id: keyBundle.key ? keyBundle.key.kid : undefined,\n      name: parsedId.name,\n      keyOperations: keyBundle.key ? (keyBundle.key.keyOps as KeyOperation[]) : undefined,\n      keyType: keyBundle.key ? keyBundle.key.kty : undefined,\n      properties: {\n        id: keyBundle.key ? keyBundle.key.kid : undefined,\n        expiresOn: attributes.expires,\n        createdOn: attributes.created,\n        updatedOn: attributes.updated,\n        ...keyBundle,\n        ...parsedId,\n        ...attributes\n      }\n    };\n\n    if (deletedKeyBundle.deletedDate) {\n      resultObject.properties.deletedOn = deletedKeyBundle.deletedDate;\n      delete (resultObject.properties as any).deletedDate;\n    }\n\n    if (attributes.vaultUrl) {\n      delete (resultObject.properties as any).vaultUrl;\n    }\n    if (attributes.expires) {\n      delete (resultObject.properties as any).expires;\n    }\n    if (attributes.created) {\n      delete (resultObject.properties as any).created;\n    }\n    if (attributes.updated) {\n      delete (resultObject.properties as any).updated;\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link DeletedKey} based on a received KeyItem.\n   */\n  private getDeletedKeyFromKeyItem(keyItem: KeyItem): DeletedKey {\n    const parsedId = parseKeyvaultEntityIdentifier(\"keys\", keyItem.kid);\n\n    const attributes = keyItem.attributes || {};\n\n    const abstractProperties: any = {\n      id: keyItem.kid,\n      deletedOn: (attributes as any).deletedDate,\n      expiresOn: attributes.expires,\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      ...keyItem,\n      ...parsedId,\n      ...keyItem.attributes\n    };\n\n    if (abstractProperties.deletedDate) {\n      delete abstractProperties.deletedDate;\n    }\n\n    if (abstractProperties.expires) {\n      delete abstractProperties.expires;\n    }\n    if (abstractProperties.created) {\n      delete abstractProperties.created;\n    }\n    if (abstractProperties.updated) {\n      delete abstractProperties.updated;\n    }\n\n    return {\n      key: keyItem,\n      id: keyItem.kid,\n      name: abstractProperties.name,\n      properties: abstractProperties\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyProperties} based on a received KeyItem.\n   */\n  private getKeyPropertiesFromKeyItem(keyItem: KeyItem): KeyProperties {\n    const parsedId = parseKeyvaultEntityIdentifier(\"keys\", keyItem.kid);\n\n    const attributes = keyItem.attributes || {};\n\n    const resultObject: any = {\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      ...keyItem,\n      ...parsedId,\n      ...keyItem.attributes\n    };\n\n    delete resultObject.attributes;\n\n    if (keyItem.attributes!.expires) {\n      resultObject.expiresOn = keyItem.attributes!.expires;\n      delete resultObject.expires;\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user.\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions?: RequestOptionsBase): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n"]}