/// <reference lib="esnext.asynciterable" />
import * as coreHttp from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-http';

/**
 * Options for {@link backupKey}.
 */
export declare interface BackupKeyOptions extends coreHttp.OperationOptions {
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginDeleteKey}
 */
export declare interface BeginDeleteKeyOptions extends KeyPollerOptions {
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginRecoverDeletedKey}
 */
export declare interface BeginRecoverDeletedKeyOptions extends KeyPollerOptions {
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link createEcKey}
 */
export declare interface CreateEcKeyOptions extends CreateKeyOptions {
    /**
     * Elliptic curve name. For valid values, see KeyCurveName.
     * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'
     */
    curve?: KeyCurveName;
    /**
     * Whether to import as a hardware key (HSM) or software key.
     */
    hsm?: boolean;
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link createKey}
 */
export declare interface CreateKeyOptions extends coreHttp.OperationOptions {
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * Json web key operations. For more
     * information on possible key operations, see KeyOperation.
     */
    keyOps?: KeyOperation[];
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Not before date in UTC.
     */
    notBefore?: Date;
    /**
     * Expiry date in UTC.
     */
    readonly expiresOn?: Date;
    /**
     * Size of the key
     */
    keySize?: number;
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link createRsaKey}
 */
export declare interface CreateRsaKeyOptions extends CreateKeyOptions {
    /**
     * The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     */
    keySize?: number;
    /**
     * Whether to import as a hardware key (HSM) or software key.
     */
    hsm?: boolean;
}

/**
 * A client used to perform cryptographic operations with Azure Key Vault keys.
 */
export declare class CryptographyClient {
    /* Excluded from this release type: getKey */
    /**
     * Encrypts the given plaintext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.encrypt("RSA1_5", Buffer.from("My Message"));
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} plaintext The text to encrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    encrypt(algorithm: EncryptionAlgorithm, plaintext: Uint8Array, options?: EncryptOptions): Promise<EncryptResult>;
    /**
     * Decrypts the given ciphertext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.decrypt("RSA1_5", encryptedBuffer);
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} ciphertext The text to decrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    decrypt(algorithm: EncryptionAlgorithm, ciphertext: Uint8Array, options?: DecryptOptions): Promise<DecryptResult>;
    /**
     * Wraps the given key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.wrapKey("RSA1_5", keyToWrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.
     * @param {Uint8Array} key The key to wrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    wrapKey(algorithm: KeyWrapAlgorithm, key: Uint8Array, options?: WrapKeyOptions): Promise<WrapResult>;
    /**
     * Unwraps the given wrapped key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.unwrapKey("RSA1_5", keyToUnwrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.
     * @param {Uint8Array} encryptedKey The encrypted key to unwrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    unwrapKey(algorithm: KeyWrapAlgorithm, encryptedKey: Uint8Array, options?: UnwrapKeyOptions): Promise<UnwrapResult>;
    /**
     * Cryptographically sign the digest of a message
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.sign("RS256", digest);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} digest The digest of the data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    sign(algorithm: SignatureAlgorithm, digest: Uint8Array, options?: SignOptions): Promise<SignResult>;
    /**
     * Verify the signed message digest
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verify("RS256", signedDigest, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.
     * @param {Uint8Array} digest The digest to verify.
     * @param {Uint8Array} signature The signature to verify the digest against.
     * @param {EncryptOptions} [options] Additional options.
     */
    verify(algorithm: SignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, options?: VerifyOptions): Promise<VerifyResult>;
    /**
     * Cryptographically sign a block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.signData("RS256", message);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} data The data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    signData(algorithm: SignatureAlgorithm, data: Uint8Array, options?: SignOptions): Promise<SignResult>;
    /**
     * Verify the signed block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verifyData("RS256", signedMessage, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.
     * @param {Uint8Array} data The signed block of data to verify.
     * @param {Uint8Array} signature The signature to verify the block against.
     * @param {EncryptOptions} [options] Additional options.
     */
    verifyData(algorithm: SignatureAlgorithm, data: Uint8Array, signature: Uint8Array, options?: VerifyOptions): Promise<VerifyResult>;
    /* Excluded from this release type: fetchFullKeyIfPossible */
    /* Excluded from this release type: getKeyID */
    /**
     * The base URL to the vault
     */
    readonly vaultUrl: string;
    /* Excluded from this release type: client */
    /**
     * A reference to the key used for the cryptographic operations.
     * Based on what was provided to the CryptographyClient constructor, it can be either a string with the URL of a KeyVault Key, or an already parsed {@link JsonWebKey}.
     */
    private key;
    /**
     * Name of the key the client represents
     */
    private name;
    /**
     * Version of the key the client represents
     */
    private version;
    /**
     * Has the client tried to fetch the full key yet
     */
    private hasTriedToGetKey;
    /**
     * Constructs a new instance of the Cryptography client for the given key
     *
     * Example usage:
     * ```ts
     * import { KeyClient, CryptographyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let keyClient = new KeyClient(vaultUrl, credentials);
     * let keyVaultKey = await keyClient.getKey("MyKey");
     *
     * let client = new CryptographyClient(keyVaultKey.id, credentials);
     * // or
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * ```
     * @param key The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof CryptographyClient
     */
    constructor(key: string | KeyVaultKey, credential: TokenCredential, pipelineOptions?: CryptographyClientOptions);
    /* Excluded from this release type: createSpan */
    /* Excluded from this release type: setParentSpan */
}

/**
 * The optional parameters accepted by the KeyVault's CryptographyClient
 */
export declare interface CryptographyClientOptions extends KeyClientOptions {
}

/**
 * An interface representing the options of the cryptography API methods, go to the {@link CryptographyClient} for more information.
 */
export declare interface CryptographyOptions extends coreHttp.OperationOptions {
}

/**
 * Options for {@link decrypt}.
 */
export declare interface DecryptOptions extends CryptographyOptions {
}

/**
 * Result of the {@link decrypt} operation.
 */
export declare interface DecryptResult {
    /**
     * Result of the {@link decrypt} operation in bytes.
     */
    result: Uint8Array;
    /**
     * The ID of the KeyVault Key used to decrypt the encrypted data.
     */
    keyID?: string;
    /**
     * The {@link EncryptionAlgorithm} used to decrypt the encrypted data.
     */
    algorithm: EncryptionAlgorithm;
}

/**
 * An interface representing a deleted KeyVault Key.
 */
export declare interface DeletedKey {
    /**
     * The key value.
     */
    key?: JsonWebKey;
    /**
     * The name of the key.
     */
    name: string;
    /**
     * Key identifier.
     */
    id?: string;
    /**
     * JsonWebKey Key Type (kty), as defined in
     * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:
     * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
     */
    keyType?: KeyType;
    /**
     * Operations allowed on this key
     */
    keyOperations?: KeyOperation[];
    /**
     * The properties of the key.
     */
    properties: KeyProperties & {
        /**
         * The url of the recovery object, used to
         * identify and recover the deleted key.
         */
        readonly recoveryId?: string;
        /**
         * The time when the key is scheduled to be purged, in UTC
         * **NOTE: This property will not be serialized. It can only be populated by
         * the server.**
         */
        readonly scheduledPurgeDate?: Date;
        /**
         * The time when the key was deleted, in UTC
         * **NOTE: This property will not be serialized. It can only be populated by
         * the server.**
         */
        deletedOn?: Date;
    };
}

/**
 * Defines values for DeletionRecoveryLevel.
 * Possible values include: 'Purgeable', 'Recoverable+Purgeable', 'Recoverable',
 * 'Recoverable+ProtectedSubscription', 'CustomizedRecoverable+Purgeable', 'CustomizedRecoverable',
 * 'CustomizedRecoverable+ProtectedSubscription'
 * @readonly
 * @enum {string}
 */
export declare type DeletionRecoveryLevel = 'Purgeable' | 'Recoverable+Purgeable' | 'Recoverable' | 'Recoverable+ProtectedSubscription' | 'CustomizedRecoverable+Purgeable' | 'CustomizedRecoverable' | 'CustomizedRecoverable+ProtectedSubscription';

/**
 * Defines values for EncryptionAlgorithm.
 * Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
 * @readonly
 * @enum {string}
 */
export declare type EncryptionAlgorithm = "RSA-OAEP" | "RSA-OAEP-256" | "RSA1_5";

/**
 * Options for {@link encrypt}.
 */
export declare interface EncryptOptions extends CryptographyOptions {
}

/**
 * Result of the {@link encrypt} operation.
 */
export declare interface EncryptResult {
    /**
     * Result of the {@link encrypt} operation in bytes.
     */
    result: Uint8Array;
    /**
     * The {@link EncryptionAlgorithm} used to encrypt the data.
     */
    algorithm: EncryptionAlgorithm;
    /**
     * The ID of the KeyVault Key used to encrypt the data.
     */
    keyID?: string;
}

/**
 * Options for {@link getDeletedKey}.
 */
export declare interface GetDeletedKeyOptions extends coreHttp.OperationOptions {
}

/**
 * Options for {@link getKey}.
 */
export declare interface GetKeyOptions extends coreHttp.OperationOptions {
    /**
     * The version of the secret to retrieve. If not
     * specified the latest version of the secret will be retrieved.
     */
    version?: string;
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link importKey}
 */
export declare interface ImportKeyOptions extends coreHttp.OperationOptions {
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * Whether to import as a hardware key (HSM) or software key.
     */
    hardwareProtected?: boolean;
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Not before date in UTC.
     */
    notBefore?: Date;
    /**
     * Expiry date in UTC.
     */
    expiresOn?: Date;
}

/**
 * As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18
 */
export declare interface JsonWebKey {
    /**
     * Key identifier.
     */
    kid?: string;
    /**
     * JsonWebKey Key Type (kty), as defined in
     * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:
     * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
     */
    kty?: KeyType;
    /**
     * Json web key operations. For more
     * information on possible key operations, see KeyOperation.
     */
    keyOps?: KeyOperation[];
    /**
     * RSA modulus.
     */
    n?: Uint8Array;
    /**
     * RSA public exponent.
     */
    e?: Uint8Array;
    /**
     * RSA private exponent, or the D component of an EC private key.
     */
    d?: Uint8Array;
    /**
     * RSA private key parameter.
     */
    dp?: Uint8Array;
    /**
     * RSA private key parameter.
     */
    dq?: Uint8Array;
    /**
     * RSA private key parameter.
     */
    qi?: Uint8Array;
    /**
     * RSA secret prime.
     */
    p?: Uint8Array;
    /**
     * RSA secret prime, with p < q.
     */
    q?: Uint8Array;
    /**
     * Symmetric key.
     */
    k?: Uint8Array;
    /**
     * HSM Token, used with 'Bring Your Own Key'.
     */
    t?: Uint8Array;
    /**
     * Elliptic curve name. For valid values, see KeyCurveName. Possible values include:
     * 'P-256', 'P-384', 'P-521', 'P-256K'
     */
    crv?: KeyCurveName;
    /**
     * X component of an EC public key.
     */
    x?: Uint8Array;
    /**
     * Y component of an EC public key.
     */
    y?: Uint8Array;
}

/**
 * The KeyClient provides methods to manage {@link KeyVaultKey} in the
 * Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultKeys. The
 * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key
 * Vault.
 */
export declare class KeyClient {
    /**
     * The base URL to the vault
     */
    readonly vaultUrl: string;
    /* Excluded from this release type: client */
    /* Excluded from this release type: pollerClient */
    /**
     * Creates an instance of KeyClient.
     *
     * Example usage:
     * ```ts
     * import { KeyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new KeyClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.
     * @memberof KeyClient
     */
    constructor(vaultUrl: string, credential: TokenCredential, pipelineOptions?: KeyClientOptions);
    /* Excluded from this release type: deleteKey */
    /* Excluded from this release type: recoverDeletedKey */
    /**
     * The create key operation can be used to create any key type in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Create an elliptic-curve key:
     * let result = await client.createKey("MyKey", "EC");
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {KeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.
     * @param {CreateKeyOptions} [options] The optional parameters.
     */
    createKey(name: string, keyType: KeyType, options?: CreateKeyOptions): Promise<KeyVaultKey>;
    /**
     * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createEcKey("MyKey", { curve: "P-256" });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateEcKeyOptions} [options] The optional parameters.
     */
    createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey>;
    /**
     * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createRsaKey("MyKey", { keySize: 2048 });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateRsaKeyOptions} [options] The optional parameters.
     */
    createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey>;
    /**
     * The import key operation may be used to import any key type into an Azure Key Vault. If the
     * named key already exists, Azure Key Vault creates a new version of the key. This operation
     * requires the keys/import permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Key contents in myKeyContents
     * let result = await client.importKey("MyKey", myKeyContents);
     * ```
     * @summary Imports an externally created key, stores it, and returns key parameters and properties
     * to the client.
     * @param {string} name Name for the imported key.
     * @param {JsonWebKey} key The JSON web key.
     * @param {ImportKeyOptions} [options] The optional parameters.
     */
    importKey(name: string, key: JsonWebKey, options?: ImportKeyOptions): Promise<KeyVaultKey>;
    /**
     * The delete operation applies to any key stored in Azure Key Vault. Individual versions
     * of a key can not be deleted, only all versions of a given key at once.
     *
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.
     *
     * This operation requires the keys/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const poller = await client.beginDeleteKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginDeleteKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedKey = await poller.pollUntilDone();
     * console.log(deletedKey);
     * ```
     * @summary Deletes a key from a specified key vault.
     * @param {string} name The name of the key.
     * @param {BeginDeleteKeyOptions} [options] The optional parameters.
     */
    beginDeleteKey(name: string, options?: BeginDeleteKeyOptions): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>>;
    /**
     * The updateKeyProperties method changes specified properties of an existing stored key. Properties that
     * are not specified in the request are left unchanged. The value of a key itself cannot be
     * changed. This operation requires the keys/set permission.
     *
     * Example usage:
     * ```ts
     * let keyName = "MyKey";
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey(keyName);
     * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });
     * ```
     * @summary Updates the properties associated with a specified key in a given key vault.
     * @param {string} name The name of the key.
     * @param {string} keyVersion The version of the key.
     * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.
     */
    updateKeyProperties(name: string, keyVersion: string, options?: UpdateKeyPropertiesOptions): Promise<KeyVaultKey>;
    /**
     * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey("MyKey");
     * ```
     * @summary Get a specified key from a given key vault.
     * @param {string} name The name of the key.
     * @param {GetKeyOptions} [options] The optional parameters.
     */
    getKey(name: string, options?: GetKeyOptions): Promise<KeyVaultKey>;
    /**
     * The getDeletedKey method returns the specified deleted key along with its properties.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getDeletedKey("MyDeletedKey");
     * ```
     * @summary Gets the specified deleted key.
     * @param {string} name The name of the key.
     * @param {GetDeletedKeyOptions} [options] The optional parameters.
     */
    getDeletedKey(name: string, options?: GetDeletedKeyOptions): Promise<DeletedKey>;
    /**
     * The purge deleted key operation removes the key permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the keys/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * const deletePoller = await client.beginDeleteKey("MyKey")
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedKey("MyKey");
     * ```
     * @summary Permanently deletes the specified key.
     * @param name The name of the key.
     * @param {PurgeDeletedKeyOptions} [options] The optional parameters.
     */
    purgeDeletedKey(name: string, options?: PurgeDeletedKeyOptions): Promise<void>;
    /**
     * Recovers the deleted key in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault.
     *
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.
     *
     * This operation requires the keys/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const deletePoller = await client.beginDeleteKey("MyKey");
     * await deletePoller.pollUntilDone();
     * const poller = await client.beginRecoverDeletedKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginRecoverDeletedKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const key = await poller.pollUntilDone();
     * console.log(key);
     * ```
     * @summary Recovers the deleted key to the latest version.
     * @param name The name of the deleted key.
     * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.
     */
    beginRecoverDeletedKey(name: string, options?: BeginRecoverDeletedKeyOptions): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>>;
    /**
     * Requests that a backup of the specified key be downloaded to the client. All versions of the
     * key will be downloaded. This operation requires the keys/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * ```
     * @summary Backs up the specified key.
     * @param {string} name The name of the key.
     * @param {BackupKeyOptions} [options] The optional parameters.
     */
    backupKey(name: string, options?: BackupKeyOptions): Promise<Uint8Array | undefined>;
    /**
     * Restores a backed up key, and all its versions, to a vault. This operation requires the
     * keys/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * // ...
     * let key = await client.restoreKeyBackup(backupContents);
     * ```
     * @summary Restores a backed up key to a vault.
     * @param {Uint8Array} backup The backup blob associated with a key bundle.
     * @param {RestoreKeyBackupOptions} [options] The optional parameters.
     */
    restoreKeyBackup(backup: Uint8Array, options?: RestoreKeyBackupOptions): Promise<KeyVaultKey>;
    /* Excluded from this release type: listPropertiesOfKeyVersionsPage */
    /* Excluded from this release type: listPropertiesOfKeyVersionsAll */
    /**
     * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided
     * in the response. This operation requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeyVersions("MyKey")) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key version: ", key);
     * }
     * ```
     * @param {string} name Name of the key to fetch versions for
     * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.
     */
    listPropertiesOfKeyVersions(name: string, options?: ListPropertiesOfKeyVersionsOptions): PagedAsyncIterableIterator<KeyProperties>;
    /* Excluded from this release type: listPropertiesOfKeysPage */
    /* Excluded from this release type: listPropertiesOfKeysAll */
    /**
     * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeys()) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key: ", key);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.
     */
    listPropertiesOfKeys(options?: ListPropertiesOfKeysOptions): PagedAsyncIterableIterator<KeyProperties>;
    /* Excluded from this release type: listDeletedKeysPage */
    /* Excluded from this release type: listDeletedKeysAll */
    /**
     * Iterates the deleted keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const deletedKey of client.listDeletedKeys()) {
     *   console.log("deleted key: ", deletedKey);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListDeletedKeysOptions} [options] The optional parameters.
     */
    listDeletedKeys(options?: ListDeletedKeysOptions): PagedAsyncIterableIterator<DeletedKey>;
    /* Excluded from this release type: getKeyFromKeyBundle */
    /* Excluded from this release type: getDeletedKeyFromKeyItem */
    /* Excluded from this release type: getKeyPropertiesFromKeyItem */
    /* Excluded from this release type: createSpan */
    /* Excluded from this release type: setParentSpan */
}

/**
 * The optional parameters accepted by the KeyVault's KeyClient
 */
export declare interface KeyClientOptions extends coreHttp.PipelineOptions {
    /**
     * The accepted versions of the KeyVault's service API.
     */
    serviceVersion?: "7.0" | "7.1";
}

/**
 * Defines values for KeyCurveName.
 * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'
 * @readonly
 * @enum {string}
 */
export declare type KeyCurveName = "P-256" | "P-384" | "P-521" | "P-256K";

/**
 * Defines values for KeyOperation.
 * Possible values include: 'encrypt', 'decrypt', 'sign', 'verify', 'wrapKey', 'unwrapKey', 'import'
 * @readonly
 * @enum {string}
 */
export declare type KeyOperation = "encrypt" | "decrypt" | "sign" | "verify" | "wrapKey" | "unwrapKey" | "import";

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginDeleteKey} and {@link beginRecoverDeletedKey}
 */
export declare interface KeyPollerOptions extends coreHttp.OperationOptions {
    /**
     * Time between each polling
     */
    intervalInMs?: number;
    /**
     * A serialized poller, used to resume an existing operation
     */
    resumeFrom?: string;
}

/**
 * An interface representing the Properties of {@link KeyVaultKey}
 */
export declare interface KeyProperties {
    /**
     * Key identifier.
     */
    id?: string;
    /**
     * The name of the key.
     */
    name: string;
    /**
     * The vault URI.
     */
    vaultUrl: string;
    /**
     * The version of the key. May be undefined.
     */
    version?: string;
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Not before date in UTC.
     */
    notBefore?: Date;
    /**
     * Expiry date in UTC.
     */
    expiresOn?: Date;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
    /**
     * Creation time in UTC.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly createdOn?: Date;
    /**
     * Last updated time in UTC.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly updatedOn?: Date;
    /**
     * Reflects the deletion recovery level currently in effect for keys in the current vault.
     * If it contains 'Purgeable' the key can be permanently deleted by a privileged
     * user; otherwise, only the system can purge the key, at the end of the
     * retention interval. Possible values include: 'Purgeable',
     * 'Recoverable+Purgeable', 'Recoverable',
     * 'Recoverable+ProtectedSubscription'
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly recoveryLevel?: DeletionRecoveryLevel;
    /**
     * The retention dates of the softDelete data.
     * The value should be >=7 and <=90 when softDelete enabled.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    recoverableDays?: number;
}

/**
 * Defines values for KeyType.
 * Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
 * @readonly
 * @enum {string}
 */
export declare type KeyType = "EC" | "EC-HSM" | "RSA" | "RSA-HSM" | "oct";

/**
 * An interface representing a KeyVault Key, with its name, value and {@link KeyProperties}.
 */
export declare interface KeyVaultKey {
    /**
     * The key value.
     */
    key?: JsonWebKey;
    /**
     * The name of the key.
     */
    name: string;
    /**
     * Key identifier.
     */
    id?: string;
    /**
     * JsonWebKey Key Type (kty), as defined in
     * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:
     * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'
     */
    keyType?: KeyType;
    /**
     * Operations allowed on this key
     */
    keyOperations?: KeyOperation[];
    /**
     * The properties of the key.
     */
    properties: KeyProperties;
}

/**
 * Supported algorithms for key wrapping/unwrapping
 */
export declare type KeyWrapAlgorithm = "RSA-OAEP" | "RSA-OAEP-256" | "RSA1_5";

/**
 * An interface representing optional parameters for KeyClient paged operations passed to {@link listDeletedKeys}.
 */
export declare interface ListDeletedKeysOptions extends coreHttp.OperationOptions {
}

/**
 * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeys}.
 */
export declare interface ListPropertiesOfKeysOptions extends coreHttp.OperationOptions {
}

/**
 * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeyVersions}.
 */
export declare interface ListPropertiesOfKeyVersionsOptions extends coreHttp.OperationOptions {
}

/**
 * The @azure/logger configuration for this package.
 */
export declare const logger: import("@azure/logger").AzureLogger;
export { PagedAsyncIterableIterator }
export { PageSettings }
export { PipelineOptions }
export { PollerLike }
export { PollOperationState }

/**
 * Options for {@link purgeDeletedKey}.
 */
export declare interface PurgeDeletedKeyOptions extends coreHttp.OperationOptions {
}

/**
 * Options for {@link restoreKeyBackup}.
 */
export declare interface RestoreKeyBackupOptions extends coreHttp.OperationOptions {
}

/**
 * Defines values for SignatureAlgorithm.
 * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512',
 * 'ES256', 'ES384', 'ES512', 'ES256K'
 * @readonly
 * @enum {string}
 */
export declare type SignatureAlgorithm = "PS256" | "PS384" | "PS512" | "RS256" | "RS384" | "RS512" | "ES256" | "ES384" | "ES512" | "ES256K";

/**
 * Options for {@link sign}.
 */
export declare interface SignOptions extends CryptographyOptions {
}

/**
 * Result of the {@link sign} operation.
 */
export declare interface SignResult {
    /**
     * Result of the {@link sign} operation in bytes.
     */
    result: Uint8Array;
    /**
     * The ID of the KeyVault Key used to sign the data.
     */
    keyID?: string;
    /**
     * The {@link EncryptionAlgorithm} used to sign the data.
     */
    algorithm: SignatureAlgorithm;
}

/**
 * Options for {@link unwrapKey}.
 */
export declare interface UnwrapKeyOptions extends CryptographyOptions {
}

/**
 * Result of the {@link unwrap} operation.
 */
export declare interface UnwrapResult {
    /**
     * Result of the {@link unwrap} operation in bytes.
     */
    result: Uint8Array;
    /**
     * The ID of the KeyVault Key used to unwrap the data.
     */
    keyID?: string;
}

/**
 * Options for {@link updateKeyProperties}.
 */
export declare interface UpdateKeyPropertiesOptions extends coreHttp.OperationOptions {
    /**
     * Json web key operations. For more
     * information on possible key operations, see KeyOperation.
     */
    keyOps?: KeyOperation[];
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Not before date in UTC.
     */
    notBefore?: Date;
    /**
     * Expiry date in UTC.
     */
    expiresOn?: Date;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    tags?: {
        [propertyName: string]: string;
    };
}

/**
 * Options for {@link verify}.
 */
export declare interface VerifyOptions extends CryptographyOptions {
}

/**
 * Result of the {@link verify} operation.
 */
export declare interface VerifyResult {
    /**
     * Result of the {@link verify} operation in bytes.
     */
    result: boolean;
    /**
     * The ID of the KeyVault Key used to verify the data.
     */
    keyID?: string;
}

/**
 * Options for {@link wrapKey}.
 */
export declare interface WrapKeyOptions extends CryptographyOptions {
}

/**
 * Result of the {@link wrap} operation.
 */
export declare interface WrapResult {
    /**
     * Result of the {@link wrap} operation in bytes.
     */
    result: Uint8Array;
    /**
     * The ID of the KeyVault Key used to wrap the data.
     */
    keyID?: string;
    /**
     * The {@link EncryptionAlgorithm} used to wrap the data.
     */
    algorithm: KeyWrapAlgorithm;
}

export { }
