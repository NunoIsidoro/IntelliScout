{"version":3,"file":"index.js","sources":["../src/log.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/keyVaultClientContext.ts","../src/generated/keyVaultClient.ts","../src/generated/utils/constants.ts","../../keyvault-common/src/challengeBasedAuthenticationPolicy.ts","../src/lro/delete/operation.ts","../src/lro/delete/poller.ts","../src/lro/recover/operation.ts","../src/lro/recover/poller.ts","../src/keysModels.ts","../src/generated/utils.ts","../src/cryptographyClient.ts","../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The @azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"keyvault-keys\");\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\n\nexport const JsonWebKey: coreHttp.CompositeMapper = {\n  serializedName: \"JsonWebKey\",\n  type: {\n    name: \"Composite\",\n    className: \"JsonWebKey\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      kty: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      n: {\n        serializedName: \"n\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      e: {\n        serializedName: \"e\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      d: {\n        serializedName: \"d\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dp: {\n        serializedName: \"dp\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dq: {\n        serializedName: \"dq\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      qi: {\n        serializedName: \"qi\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      p: {\n        serializedName: \"p\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      q: {\n        serializedName: \"q\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      k: {\n        serializedName: \"k\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      t: {\n        serializedName: \"key_hsm\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      crv: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      },\n      x: {\n        serializedName: \"x\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      y: {\n        serializedName: \"y\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const Attributes: coreHttp.CompositeMapper = {\n  serializedName: \"Attributes\",\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      enabled: {\n        serializedName: \"enabled\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      notBefore: {\n        serializedName: \"nbf\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      expires: {\n        serializedName: \"exp\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      created: {\n        readOnly: true,\n        serializedName: \"created\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        readOnly: true,\n        serializedName: \"updated\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyAttributes: coreHttp.CompositeMapper = {\n  serializedName: \"KeyAttributes\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyAttributes\",\n    modelProperties: {\n      ...Attributes.type.modelProperties,\n      recoverableDays: {\n        readOnly: true,\n        serializedName: \"recoverableDays\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      recoveryLevel: {\n        nullable: false,\n        readOnly: true,\n        serializedName: \"recoveryLevel\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyBundle: coreHttp.CompositeMapper = {\n  serializedName: \"KeyBundle\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyBundle\",\n    modelProperties: {\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      managed: {\n        readOnly: true,\n        serializedName: \"managed\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyItem: coreHttp.CompositeMapper = {\n  serializedName: \"KeyItem\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyItem\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      managed: {\n        readOnly: true,\n        serializedName: \"managed\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyBundle: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedKeyBundle\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyBundle\",\n    modelProperties: {\n      ...KeyBundle.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        readOnly: true,\n        serializedName: \"scheduledPurgeDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        readOnly: true,\n        serializedName: \"deletedDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyItem: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedKeyItem\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyItem\",\n    modelProperties: {\n      ...KeyItem.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        readOnly: true,\n        serializedName: \"scheduledPurgeDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        readOnly: true,\n        serializedName: \"deletedDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyProperties: coreHttp.CompositeMapper = {\n  serializedName: \"KeyProperties\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyProperties\",\n    modelProperties: {\n      exportable: {\n        serializedName: \"exportable\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      keyType: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      reuseKey: {\n        serializedName: \"reuse_key\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyCreateParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyCreateParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyCreateParameters\",\n    modelProperties: {\n      kty: {\n        required: true,\n        serializedName: \"kty\",\n        constraints: {\n          MinLength: 1\n        },\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyImportParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyImportParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyImportParameters\",\n    modelProperties: {\n      hsm: {\n        serializedName: \"Hsm\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      key: {\n        required: true,\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationsParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyOperationsParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationsParameters\",\n    modelProperties: {\n      algorithm: {\n        required: true,\n        serializedName: \"alg\",\n        constraints: {\n          MinLength: 1\n        },\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeySignParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeySignParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeySignParameters\",\n    modelProperties: {\n      algorithm: {\n        required: true,\n        serializedName: \"alg\",\n        constraints: {\n          MinLength: 1\n        },\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyVerifyParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyParameters\",\n    modelProperties: {\n      algorithm: {\n        required: true,\n        serializedName: \"alg\",\n        constraints: {\n          MinLength: 1\n        },\n        type: {\n          name: \"String\"\n        }\n      },\n      digest: {\n        required: true,\n        serializedName: \"digest\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      signature: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyUpdateParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyUpdateParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyUpdateParameters\",\n    modelProperties: {\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const KeyRestoreParameters: coreHttp.CompositeMapper = {\n  serializedName: \"KeyRestoreParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyRestoreParameters\",\n    modelProperties: {\n      keyBundleBackup: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationResult: coreHttp.CompositeMapper = {\n  serializedName: \"KeyOperationResult\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationResult\",\n    modelProperties: {\n      kid: {\n        readOnly: true,\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      result: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyResult: coreHttp.CompositeMapper = {\n  serializedName: \"KeyVerifyResult\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyListResult: coreHttp.CompositeMapper = {\n  serializedName: \"KeyListResult\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyListResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"KeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        readOnly: true,\n        serializedName: \"nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyListResult: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedKeyListResult\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyListResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DeletedKeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        readOnly: true,\n        serializedName: \"nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const BackupKeyResult: coreHttp.CompositeMapper = {\n  serializedName: \"BackupKeyResult\",\n  type: {\n    name: \"Composite\",\n    className: \"BackupKeyResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorModel: coreHttp.CompositeMapper = {\n  serializedName: \"Error\",\n  type: {\n    name: \"Composite\",\n    className: \"ErrorModel\",\n    modelProperties: {\n      code: {\n        readOnly: true,\n        serializedName: \"code\",\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        readOnly: true,\n        serializedName: \"message\",\n        type: {\n          name: \"String\"\n        }\n      },\n      innerError: {\n        readOnly: true,\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVaultError: coreHttp.CompositeMapper = {\n  serializedName: \"KeyVaultError\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyVaultError\",\n    modelProperties: {\n      error: {\n        readOnly: true,\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nexport const apiVersion: coreHttp.OperationQueryParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    required: true,\n    serializedName: \"api-version\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const keyName0: coreHttp.OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    required: true,\n    serializedName: \"key-name\",\n    constraints: {\n      Pattern: /^[0-9a-zA-Z-]+$/\n    },\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const keyName1: coreHttp.OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    required: true,\n    serializedName: \"key-name\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const keyVersion: coreHttp.OperationURLParameter = {\n  parameterPath: \"keyVersion\",\n  mapper: {\n    required: true,\n    serializedName: \"key-version\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const maxresults: coreHttp.OperationQueryParameter = {\n  parameterPath: [\n    \"options\",\n    \"maxresults\"\n  ],\n  mapper: {\n    serializedName: \"maxresults\",\n    constraints: {\n      InclusiveMaximum: 25,\n      InclusiveMinimum: 1\n    },\n    type: {\n      name: \"Number\"\n    }\n  }\n};\nexport const vaultBaseUrl: coreHttp.OperationURLParameter = {\n  parameterPath: \"vaultBaseUrl\",\n  mapper: {\n    required: true,\n    serializedName: \"vaultBaseUrl\",\n    defaultValue: '',\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nconst packageName = \"@azure/keyvault-keys\";\nexport const packageVersion = \"4.1.0\";\n\nexport class KeyVaultClientContext extends coreHttp.ServiceClient {\n  apiVersion: string;\n\n  /**\n   * Initializes a new instance of the KeyVaultClientContext class.\n   * @param apiVersion Client API version.\n   * @param [options] The parameter options\n   */\n  constructor(apiVersion: string, options?: coreHttp.ServiceClientOptions) {\n    if (apiVersion == undefined) {\n      throw new Error(\"'apiVersion' cannot be null.\");\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.userAgent) {\n      const defaultUserAgent = coreHttp.getDefaultUserAgentValue();\n      options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;\n    }\n\n    super(undefined, options);\n\n    this.baseUri = \"{vaultBaseUrl}\";\n    this.requestContentType = \"application/json; charset=utf-8\";\n    this.apiVersion = apiVersion;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Models from \"./models\";\nimport * as Mappers from \"./models/mappers\";\nimport * as Parameters from \"./models/parameters\";\nimport { KeyVaultClientContext } from \"./keyVaultClientContext\";\n\nclass KeyVaultClient extends KeyVaultClientContext {\n  /**\n   * Initializes a new instance of the KeyVaultClient class.\n   * @param apiVersion Client API version.\n   * @param [options] The parameter options\n   */\n  constructor(apiVersion: string, options?: coreHttp.ServiceClientOptions) {\n    super(apiVersion, options);\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   * @summary Creates a new key, stores it, then returns key parameters and attributes to the client.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name for the new key. The system will generate the version name for the new\n   * key.\n   * @param kty The type of key to create. For valid values, see JsonWebKeyType. Possible values\n   * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   * @param [options] The optional parameters\n   * @returns Promise<Models.CreateKeyResponse>\n   */\n  createKey(vaultBaseUrl: string, keyName: string, kty: Models.JsonWebKeyType, options?: Models.KeyVaultClientCreateKeyOptionalParams): Promise<Models.CreateKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name for the new key. The system will generate the version name for the new\n   * key.\n   * @param kty The type of key to create. For valid values, see JsonWebKeyType. Possible values\n   * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   * @param callback The callback\n   */\n  createKey(vaultBaseUrl: string, keyName: string, kty: Models.JsonWebKeyType, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name for the new key. The system will generate the version name for the new\n   * key.\n   * @param kty The type of key to create. For valid values, see JsonWebKeyType. Possible values\n   * include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  createKey(vaultBaseUrl: string, keyName: string, kty: Models.JsonWebKeyType, options: Models.KeyVaultClientCreateKeyOptionalParams, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  createKey(vaultBaseUrl: string, keyName: string, kty: Models.JsonWebKeyType, options?: Models.KeyVaultClientCreateKeyOptionalParams | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.CreateKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        kty,\n        options\n      },\n      createKeyOperationSpec,\n      callback) as Promise<Models.CreateKeyResponse>;\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   * @summary Imports an externally created key, stores it, and returns key parameters and attributes\n   * to the client.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName Name for the imported key.\n   * @param key The Json web key\n   * @param [options] The optional parameters\n   * @returns Promise<Models.ImportKeyResponse>\n   */\n  importKey(vaultBaseUrl: string, keyName: string, key: Models.JsonWebKey, options?: Models.KeyVaultClientImportKeyOptionalParams): Promise<Models.ImportKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName Name for the imported key.\n   * @param key The Json web key\n   * @param callback The callback\n   */\n  importKey(vaultBaseUrl: string, keyName: string, key: Models.JsonWebKey, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName Name for the imported key.\n   * @param key The Json web key\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  importKey(vaultBaseUrl: string, keyName: string, key: Models.JsonWebKey, options: Models.KeyVaultClientImportKeyOptionalParams, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  importKey(vaultBaseUrl: string, keyName: string, key: Models.JsonWebKey, options?: Models.KeyVaultClientImportKeyOptionalParams | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.ImportKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        key,\n        options\n      },\n      importKeyOperationSpec,\n      callback) as Promise<Models.ImportKeyResponse>;\n  }\n\n  /**\n   * The delete key operation cannot be used to remove individual versions of a key. This operation\n   * removes the cryptographic material associated with the key, which means the key is not usable\n   * for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the\n   * keys/delete permission.\n   * @summary Deletes a key of any type from storage in Azure Key Vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to delete.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DeleteKeyResponse>\n   */\n  deleteKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.DeleteKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to delete.\n   * @param callback The callback\n   */\n  deleteKey(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to delete.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  deleteKey(vaultBaseUrl: string, keyName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): void;\n  deleteKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.DeletedKeyBundle>, callback?: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): Promise<Models.DeleteKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      deleteKeyOperationSpec,\n      callback) as Promise<Models.DeleteKeyResponse>;\n  }\n\n  /**\n   * In order to perform this operation, the key must already exist in the Key Vault. Note: The\n   * cryptographic material of a key itself cannot be changed. This operation requires the\n   * keys/update permission.\n   * @summary The update key operation changes specified attributes of a stored key and can be\n   * applied to any key type and key version stored in Azure Key Vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to update.\n   * @param keyVersion The version of the key to update.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.UpdateKeyResponse>\n   */\n  updateKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options?: Models.KeyVaultClientUpdateKeyOptionalParams): Promise<Models.UpdateKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to update.\n   * @param keyVersion The version of the key to update.\n   * @param callback The callback\n   */\n  updateKey(vaultBaseUrl: string, keyName: string, keyVersion: string, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to update.\n   * @param keyVersion The version of the key to update.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  updateKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options: Models.KeyVaultClientUpdateKeyOptionalParams, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  updateKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options?: Models.KeyVaultClientUpdateKeyOptionalParams | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.UpdateKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        options\n      },\n      updateKeyOperationSpec,\n      callback) as Promise<Models.UpdateKeyResponse>;\n  }\n\n  /**\n   * The get key operation is applicable to all key types. If the requested key is symmetric, then no\n   * key material is released in the response. This operation requires the keys/get permission.\n   * @summary Gets the public part of a stored key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI\n   * fragment is optional. If not specified, the latest version of the key is returned.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetKeyResponse>\n   */\n  getKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options?: coreHttp.RequestOptionsBase): Promise<Models.GetKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI\n   * fragment is optional. If not specified, the latest version of the key is returned.\n   * @param callback The callback\n   */\n  getKey(vaultBaseUrl: string, keyName: string, keyVersion: string, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI\n   * fragment is optional. If not specified, the latest version of the key is returned.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  getKey(vaultBaseUrl: string, keyName: string, keyVersion: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.GetKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        options\n      },\n      getKeyOperationSpec,\n      callback) as Promise<Models.GetKeyResponse>;\n  }\n\n  /**\n   * The full key identifier, attributes, and tags are provided in the response. This operation\n   * requires the keys/list permission.\n   * @summary Retrieves a list of individual key versions with the same key name.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetKeyVersionsResponse>\n   */\n  getKeyVersions(vaultBaseUrl: string, keyName: string, options?: Models.KeyVaultClientGetKeyVersionsOptionalParams): Promise<Models.GetKeyVersionsResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param callback The callback\n   */\n  getKeyVersions(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<Models.KeyListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getKeyVersions(vaultBaseUrl: string, keyName: string, options: Models.KeyVaultClientGetKeyVersionsOptionalParams, callback: coreHttp.ServiceCallback<Models.KeyListResult>): void;\n  getKeyVersions(vaultBaseUrl: string, keyName: string, options?: Models.KeyVaultClientGetKeyVersionsOptionalParams | coreHttp.ServiceCallback<Models.KeyListResult>, callback?: coreHttp.ServiceCallback<Models.KeyListResult>): Promise<Models.GetKeyVersionsResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      getKeyVersionsOperationSpec,\n      callback) as Promise<Models.GetKeyVersionsResponse>;\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a stored key. The LIST operation is applicable to all key types, however only the base\n   * key identifier, attributes, and tags are provided in the response. Individual versions of a key\n   * are not listed in the response. This operation requires the keys/list permission.\n   * @summary List keys in the specified vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetKeysResponse>\n   */\n  getKeys(vaultBaseUrl: string, options?: Models.KeyVaultClientGetKeysOptionalParams): Promise<Models.GetKeysResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param callback The callback\n   */\n  getKeys(vaultBaseUrl: string, callback: coreHttp.ServiceCallback<Models.KeyListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getKeys(vaultBaseUrl: string, options: Models.KeyVaultClientGetKeysOptionalParams, callback: coreHttp.ServiceCallback<Models.KeyListResult>): void;\n  getKeys(vaultBaseUrl: string, options?: Models.KeyVaultClientGetKeysOptionalParams | coreHttp.ServiceCallback<Models.KeyListResult>, callback?: coreHttp.ServiceCallback<Models.KeyListResult>): Promise<Models.GetKeysResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        options\n      },\n      getKeysOperationSpec,\n      callback) as Promise<Models.GetKeysResponse>;\n  }\n\n  /**\n   * The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this\n   * operation does NOT return key material in a form that can be used outside the Azure Key Vault\n   * system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key\n   * Vault itself. The intent of this operation is to allow a client to GENERATE a key in one Azure\n   * Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance.\n   * The BACKUP operation may be used to export, in protected form, any key type from Azure Key\n   * Vault. Individual versions of a key cannot be backed up. BACKUP / RESTORE can be performed\n   * within geographical boundaries only; meaning that a BACKUP from one geographical area cannot be\n   * restored to another geographical area. For example, a backup from the US geographical area\n   * cannot be restored in an EU geographical area. This operation requires the key/backup\n   * permission.\n   * @summary Requests that a backup of the specified key be downloaded to the client.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.BackupKeyResponse>\n   */\n  backupKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.BackupKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param callback The callback\n   */\n  backupKey(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<Models.BackupKeyResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  backupKey(vaultBaseUrl: string, keyName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.BackupKeyResult>): void;\n  backupKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.BackupKeyResult>, callback?: coreHttp.ServiceCallback<Models.BackupKeyResult>): Promise<Models.BackupKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      backupKeyOperationSpec,\n      callback) as Promise<Models.BackupKeyResponse>;\n  }\n\n  /**\n   * Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,\n   * attributes and access control policies. The RESTORE operation may be used to import a previously\n   * backed up key. Individual versions of a key cannot be restored. The key is restored in its\n   * entirety with the same key name as it had when it was backed up. If the key name is not\n   * available in the target Key Vault, the RESTORE operation will be rejected. While the key name is\n   * retained during restore, the final key identifier will change if the key is restored to a\n   * different vault. Restore will restore all versions and preserve version identifiers. The RESTORE\n   * operation is subject to security constraints: The target Key Vault must be owned by the same\n   * Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission in\n   * the target Key Vault. This operation requires the keys/restore permission.\n   * @summary Restores a backed up key to a vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyBundleBackup The backup blob associated with a key bundle.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.RestoreKeyResponse>\n   */\n  restoreKey(vaultBaseUrl: string, keyBundleBackup: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.RestoreKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyBundleBackup The backup blob associated with a key bundle.\n   * @param callback The callback\n   */\n  restoreKey(vaultBaseUrl: string, keyBundleBackup: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyBundleBackup The backup blob associated with a key bundle.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  restoreKey(vaultBaseUrl: string, keyBundleBackup: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  restoreKey(vaultBaseUrl: string, keyBundleBackup: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.RestoreKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyBundleBackup,\n        options\n      },\n      restoreKeyOperationSpec,\n      callback) as Promise<Models.RestoreKeyResponse>;\n  }\n\n  /**\n   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is\n   * stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data,\n   * the size of which is dependent on the target key and the encryption algorithm to be used. The\n   * ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault since\n   * protection with an asymmetric key can be performed using public portion of the key. This\n   * operation is supported for asymmetric keys as a convenience for callers that have a\n   * key-reference but do not have access to the public key material. This operation requires the\n   * keys/encrypt permission.\n   * @summary Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key\n   * vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param [options] The optional parameters\n   * @returns Promise<Models.EncryptResponse>\n   */\n  encrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.EncryptResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param callback The callback\n   */\n  encrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  encrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  encrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyOperationResult>, callback?: coreHttp.ServiceCallback<Models.KeyOperationResult>): Promise<Models.EncryptResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        value,\n        options\n      },\n      encryptOperationSpec,\n      callback) as Promise<Models.EncryptResponse>;\n  }\n\n  /**\n   * The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key\n   * and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single\n   * block of data may be decrypted, the size of this block is dependent on the target key and the\n   * algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys stored in\n   * Azure Key Vault since it uses the private portion of the key. This operation requires the\n   * keys/decrypt permission.\n   * @summary Decrypts a single block of encrypted data.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DecryptResponse>\n   */\n  decrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.DecryptResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param callback The callback\n   */\n  decrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  decrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  decrypt(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyOperationResult>, callback?: coreHttp.ServiceCallback<Models.KeyOperationResult>): Promise<Models.DecryptResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        value,\n        options\n      },\n      decryptOperationSpec,\n      callback) as Promise<Models.DecryptResponse>;\n  }\n\n  /**\n   * The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault\n   * since this operation uses the private portion of the key. This operation requires the keys/sign\n   * permission.\n   * @summary Creates a signature from a digest using the specified key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm identifier. For more information on possible\n   * algorithm types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',\n   * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param value\n   * @param [options] The optional parameters\n   * @returns Promise<Models.SignResponse>\n   */\n  sign(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.SignResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm identifier. For more information on possible\n   * algorithm types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',\n   * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param value\n   * @param callback The callback\n   */\n  sign(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, value: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm identifier. For more information on possible\n   * algorithm types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',\n   * 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param value\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  sign(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, value: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  sign(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyOperationResult>, callback?: coreHttp.ServiceCallback<Models.KeyOperationResult>): Promise<Models.SignResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        value,\n        options\n      },\n      signOperationSpec,\n      callback) as Promise<Models.SignResponse>;\n  }\n\n  /**\n   * The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not\n   * strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification\n   * can be performed using the public portion of the key but this operation is supported as a\n   * convenience for callers that only have a key-reference and not the public portion of the key.\n   * This operation requires the keys/verify permission.\n   * @summary Verifies a signature using a specified key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm. For more information on possible algorithm\n   * types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384', 'PS512',\n   * 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param digest The digest used for signing.\n   * @param signature The signature to be verified.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.VerifyResponse>\n   */\n  verify(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.VerifyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm. For more information on possible algorithm\n   * types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384', 'PS512',\n   * 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param digest The digest used for signing.\n   * @param signature The signature to be verified.\n   * @param callback The callback\n   */\n  verify(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyVerifyResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm. For more information on possible algorithm\n   * types, see JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384', 'PS512',\n   * 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512', 'ES256K'\n   * @param digest The digest used for signing.\n   * @param signature The signature to be verified.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  verify(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyVerifyResult>): void;\n  verify(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeySignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyVerifyResult>, callback?: coreHttp.ServiceCallback<Models.KeyVerifyResult>): Promise<Models.VerifyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        digest,\n        signature,\n        options\n      },\n      verifyOperationSpec,\n      callback) as Promise<Models.VerifyResponse>;\n  }\n\n  /**\n   * The WRAP operation supports encryption of a symmetric key using a key encryption key that has\n   * previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for\n   * symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be\n   * performed using the public portion of the key. This operation is supported for asymmetric keys\n   * as a convenience for callers that have a key-reference but do not have access to the public key\n   * material. This operation requires the keys/wrapKey permission.\n   * @summary Wraps a symmetric key using a specified key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param [options] The optional parameters\n   * @returns Promise<Models.WrapKeyResponse>\n   */\n  wrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.WrapKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param callback The callback\n   */\n  wrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  wrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  wrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyOperationResult>, callback?: coreHttp.ServiceCallback<Models.KeyOperationResult>): Promise<Models.WrapKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        value,\n        options\n      },\n      wrapKeyOperationSpec,\n      callback) as Promise<Models.WrapKeyResponse>;\n  }\n\n  /**\n   * The UNWRAP operation supports decryption of a symmetric key using the target key encryption key.\n   * This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric\n   * and symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This\n   * operation requires the keys/unwrapKey permission.\n   * @summary Unwraps a symmetric key using the specified key that was initially used for wrapping\n   * that key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param [options] The optional parameters\n   * @returns Promise<Models.UnwrapKeyResponse>\n   */\n  unwrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.UnwrapKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param callback The callback\n   */\n  unwrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier. Possible values include: 'RSA-OAEP', 'RSA-OAEP-256',\n   * 'RSA1_5'\n   * @param value\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  unwrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyOperationResult>): void;\n  unwrapKey(vaultBaseUrl: string, keyName: string, keyVersion: string, algorithm: Models.JsonWebKeyEncryptionAlgorithm, value: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyOperationResult>, callback?: coreHttp.ServiceCallback<Models.KeyOperationResult>): Promise<Models.UnwrapKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        keyVersion,\n        algorithm,\n        value,\n        options\n      },\n      unwrapKeyOperationSpec,\n      callback) as Promise<Models.UnwrapKeyResponse>;\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a deleted key. This operation includes deletion-specific information. The Get Deleted\n   * Keys operation is applicable for vaults enabled for soft-delete. While the operation can be\n   * invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.\n   * This operation requires the keys/list permission.\n   * @summary Lists the deleted keys in the specified vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetDeletedKeysResponse>\n   */\n  getDeletedKeys(vaultBaseUrl: string, options?: Models.KeyVaultClientGetDeletedKeysOptionalParams): Promise<Models.GetDeletedKeysResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param callback The callback\n   */\n  getDeletedKeys(vaultBaseUrl: string, callback: coreHttp.ServiceCallback<Models.DeletedKeyListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getDeletedKeys(vaultBaseUrl: string, options: Models.KeyVaultClientGetDeletedKeysOptionalParams, callback: coreHttp.ServiceCallback<Models.DeletedKeyListResult>): void;\n  getDeletedKeys(vaultBaseUrl: string, options?: Models.KeyVaultClientGetDeletedKeysOptionalParams | coreHttp.ServiceCallback<Models.DeletedKeyListResult>, callback?: coreHttp.ServiceCallback<Models.DeletedKeyListResult>): Promise<Models.GetDeletedKeysResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        options\n      },\n      getDeletedKeysOperationSpec,\n      callback) as Promise<Models.GetDeletedKeysResponse>;\n  }\n\n  /**\n   * The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation\n   * can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled\n   * vault. This operation requires the keys/get permission.\n   * @summary Gets the public part of a deleted key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetDeletedKeyResponse>\n   */\n  getDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.GetDeletedKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param callback The callback\n   */\n  getDeletedKey(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getDeletedKey(vaultBaseUrl: string, keyName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): void;\n  getDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.DeletedKeyBundle>, callback?: coreHttp.ServiceCallback<Models.DeletedKeyBundle>): Promise<Models.GetDeletedKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      getDeletedKeyOperationSpec,\n      callback) as Promise<Models.GetDeletedKeyResponse>;\n  }\n\n  /**\n   * The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the\n   * operation can be invoked on any vault, it will return an error if invoked on a non soft-delete\n   * enabled vault. This operation requires the keys/purge permission.\n   * @summary Permanently deletes the specified key.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key\n   * @param [options] The optional parameters\n   * @returns Promise<coreHttp.RestResponse>\n   */\n  purgeDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase): Promise<coreHttp.RestResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key\n   * @param callback The callback\n   */\n  purgeDeletedKey(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  purgeDeletedKey(vaultBaseUrl: string, keyName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<void>): void;\n  purgeDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<coreHttp.RestResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      purgeDeletedKeyOperationSpec,\n      callback);\n  }\n\n  /**\n   * The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.\n   * It recovers the deleted key back to its latest version under /keys. An attempt to recover an\n   * non-deleted key will return an error. Consider this the inverse of the delete operation on\n   * soft-delete enabled vaults. This operation requires the keys/recover permission.\n   * @summary Recovers the deleted key to its latest version.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the deleted key.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.RecoverDeletedKeyResponse>\n   */\n  recoverDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.RecoverDeletedKeyResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the deleted key.\n   * @param callback The callback\n   */\n  recoverDeletedKey(vaultBaseUrl: string, keyName: string, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the deleted key.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  recoverDeletedKey(vaultBaseUrl: string, keyName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.KeyBundle>): void;\n  recoverDeletedKey(vaultBaseUrl: string, keyName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.KeyBundle>, callback?: coreHttp.ServiceCallback<Models.KeyBundle>): Promise<Models.RecoverDeletedKeyResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        keyName,\n        options\n      },\n      recoverDeletedKeyOperationSpec,\n      callback) as Promise<Models.RecoverDeletedKeyResponse>;\n  }\n}\n\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers);\nconst createKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/create\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName0\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      kty: \"kty\",\n      keySize: [\n        \"options\",\n        \"keySize\"\n      ],\n      keyOps: [\n        \"options\",\n        \"keyOps\"\n      ],\n      keyAttributes: [\n        \"options\",\n        \"keyAttributes\"\n      ],\n      tags: [\n        \"options\",\n        \"tags\"\n      ],\n      curve: [\n        \"options\",\n        \"curve\"\n      ]\n    },\n    mapper: {\n      ...Mappers.KeyCreateParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst importKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PUT\",\n  path: \"keys/{key-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName0\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      hsm: [\n        \"options\",\n        \"hsm\"\n      ],\n      key: \"key\",\n      keyAttributes: [\n        \"options\",\n        \"keyAttributes\"\n      ],\n      tags: [\n        \"options\",\n        \"tags\"\n      ]\n    },\n    mapper: {\n      ...Mappers.KeyImportParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst deleteKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"keys/{key-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst updateKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PATCH\",\n  path: \"keys/{key-name}/{key-version}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      keyOps: [\n        \"options\",\n        \"keyOps\"\n      ],\n      keyAttributes: [\n        \"options\",\n        \"keyAttributes\"\n      ],\n      tags: [\n        \"options\",\n        \"tags\"\n      ]\n    },\n    mapper: {\n      ...Mappers.KeyUpdateParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"keys/{key-name}/{key-version}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getKeyVersionsOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"keys/{key-name}/versions\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getKeysOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"keys\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst backupKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/backup\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.BackupKeyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst restoreKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/restore\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      keyBundleBackup: \"keyBundleBackup\"\n    },\n    mapper: {\n      ...Mappers.KeyRestoreParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst encryptOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/encrypt\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      value: \"value\"\n    },\n    mapper: {\n      ...Mappers.KeyOperationsParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst decryptOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/decrypt\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      value: \"value\"\n    },\n    mapper: {\n      ...Mappers.KeyOperationsParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst signOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/sign\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      value: \"value\"\n    },\n    mapper: {\n      ...Mappers.KeySignParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst verifyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/verify\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      digest: \"digest\",\n      signature: \"signature\"\n    },\n    mapper: {\n      ...Mappers.KeyVerifyParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyVerifyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst wrapKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/wrapkey\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      value: \"value\"\n    },\n    mapper: {\n      ...Mappers.KeyOperationsParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst unwrapKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"keys/{key-name}/{key-version}/unwrapkey\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      algorithm: \"algorithm\",\n      value: \"value\"\n    },\n    mapper: {\n      ...Mappers.KeyOperationsParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getDeletedKeysOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"deletedkeys\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"deletedkeys/{key-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst purgeDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"deletedkeys/{key-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst recoverDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"deletedkeys/{key-name}/recover\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nexport {\n  KeyVaultClient,\n  KeyVaultClientContext,\n  Models as KeyVaultModels,\n  Mappers as KeyVaultMappers\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nexport const SDK_VERSION: string = \"4.1.0\";\n\nexport const RetryConstants = {\n  MIN_RETRY_INTERVAL_MS: 3000\n};\n\nexport const HeaderConstants = {\n  USER_AGENT: \"User-Agent\",\n  X_MS_CLIENT_REQUEST_ID: \"x-ms-client-request-id\"\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport { TokenCredential } from \"@azure/core-http\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory,\n} from \"@azure/core-http\";\nimport { Constants } from \"@azure/core-http\";\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport { WebResource } from \"@azure/core-http\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"@azure/core-http\";\n\ntype ValidParsedWWWAuthenticateProperties =\n  // \"authorization_uri\" was used in the track 1 version of KeyVault.\n  // This is not a relevant property anymore, since the service is consistently answering with \"authorization\".\n  // | \"authorization_uri\"\n  | \"authorization\"\n  // Even though the service is moving to \"scope\", both \"resource\" and \"scope\" should be supported.\n  | \"resource\"\n  | \"scope\";\n\ntype ParsedWWWAuthenticate = {\n  [Key in ValidParsedWWWAuthenticateProperties]?: string;\n};\n\n/**\n * Representation of the Authentication Challenge\n */\nexport class AuthenticationChallenge {\n  constructor(public authorization: string, public scope: string) {}\n\n  /**\n   * Checks that this AuthenticationChallenge is equal to another one given.\n   * Only compares the scope.\n   * This is exactly what C# is doing, as we can see here:\n   * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147\n   * @param other The other AuthenticationChallenge\n   */\n  public equalTo(other: AuthenticationChallenge | undefined) {\n    return other\n      ? this.scope.toLowerCase() === other.scope.toLowerCase() &&\n          this.authorization.toLowerCase() === other.authorization.toLowerCase()\n      : false;\n  }\n}\n\n/**\n * Helps keep a copy of any previous authentication challenges,\n * so that we can compare on any further request.\n */\nexport class AuthenticationChallengeCache {\n  public challenge?: AuthenticationChallenge;\n\n  public setCachedChallenge(challenge: AuthenticationChallenge) {\n    this.challenge = challenge;\n  }\n}\n\n/**\n * Creates a new ChallengeBasedAuthenticationPolicy factory.\n *\n * @param credential The TokenCredential implementation that can supply the challenge token.\n */\nexport function challengeBasedAuthenticationPolicy(\n  credential: TokenCredential\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const challengeCache = new AuthenticationChallengeCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ChallengeBasedAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        tokenCache,\n        challengeCache\n      );\n    },\n  };\n}\n\n/**\n * Parses an WWW-Authenticate response.\n * This transforms a string value like:\n * `Bearer authorization=\"some_authorization\", resource=\"https://some.url\"`\n * into an object like:\n * `{ authorization: \"some_authorization\", resource: \"https://some.url\" }`\n * @param wwwAuthenticate string value in the WWW-Authenticate header\n */\nexport function parseWWWAuthenticate(wwwAuthenticate: string): ParsedWWWAuthenticate {\n  // First we split the string by either `, ` or ` `.\n  const parts = wwwAuthenticate.split(/,* +/);\n  // Then we only keep the strings with an equal sign after a word and before a quote.\n  // also splitting these sections by their equal sign\n  const keyValues = parts.reduce<string[][]>(\n    (parts, str) => (str.match(/\\w=\"/) ? [...parts, str.split(\"=\")] : parts),\n    []\n  );\n  // Then we transform these key-value pairs back into an object.\n  const parsed = keyValues.reduce<ParsedWWWAuthenticate>(\n    (result, [key, value]: string[]) => ({\n      ...result,\n      [key]: value.slice(1, -1),\n    }),\n    {}\n  );\n  return parsed;\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class ChallengeBasedAuthenticationPolicy extends BaseRequestPolicy {\n  private parseWWWAuthenticate: (\n    wwwAuthenticate: string\n  ) => ParsedWWWAuthenticate = parseWWWAuthenticate;\n\n  /**\n   * Creates a new ChallengeBasedAuthenticationPolicy object.\n   *\n   * @param nextPolicy The next RequestPolicy in the request pipeline.\n   * @param options Options for this RequestPolicy.\n   * @param credential The TokenCredential implementation that can supply the bearer token.\n   * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private tokenCache: AccessTokenCache,\n    private challengeCache: AuthenticationChallengeCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Gets or updates the token from the token cache into the headers of the received web resource.\n   */\n  private async loadToken(webResource: WebResource): Promise<void> {\n    let accessToken = this.tokenCache.getCachedToken();\n\n    // If there's no cached token in the cache, we try to get a new one.\n    if (accessToken === undefined) {\n      const receivedToken = await this.credential.getToken(this.challengeCache.challenge!.scope);\n      accessToken = receivedToken || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    if (accessToken) {\n      webResource.headers.set(\n        Constants.HeaderConstants.AUTHORIZATION,\n        `Bearer ${accessToken.token}`\n      );\n    }\n  }\n\n  /**\n   * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,\n   * then if the challenge is different from the one cached, resets the token and forces\n   * a re-authentication, otherwise continues with the existing challenge and token.\n   * @param wwwAuthenticate Value of the incoming WWW-Authenticate header.\n   * @param webResource Ongoing HTTP request.\n   */\n  private async regenerateChallenge(\n    wwwAuthenticate: string,\n    webResource: WebResource\n  ): Promise<HttpOperationResponse> {\n    // The challenge based authentication will contain both:\n    // - An authorization URI with a token,\n    // - The resource to which that token is valid against (also called the scope).\n    const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);\n    const authorization = parsedWWWAuth.authorization!;\n    const resource = parsedWWWAuth.resource! || parsedWWWAuth.scope!;\n\n    if (!(authorization && resource)) {\n      return this._nextPolicy.sendRequest(webResource);\n    }\n\n    const challenge = new AuthenticationChallenge(authorization, resource + \"/.default\");\n\n    // Either if there's no cached challenge at this point (could have happen in parallel),\n    // or if the cached challenge has a different scope,\n    // we store the just received challenge and reset the cached token, to force a re-authentication.\n    if (!this.challengeCache.challenge?.equalTo(challenge)) {\n      this.challengeCache.setCachedChallenge(challenge);\n      this.tokenCache.setCachedToken(undefined);\n    }\n\n    await this.loadToken(webResource);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource Ongoing HTTP request.\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    // Ensure that we're about to use a secure connection.\n    if (!webResource.url.startsWith(\"https:\")) {\n      throw new Error(\"The resource address for authorization must use the 'https' protocol.\");\n    }\n\n    // The next request will happen differently whether we have a challenge or not.\n    let response: HttpOperationResponse;\n\n    if (this.challengeCache.challenge == undefined) {\n      // If there's no challenge in cache, a blank body will start the challenge.\n      const originalBody = webResource.body;\n      webResource.body = \"\";\n      response = await this._nextPolicy.sendRequest(webResource);\n      webResource.body = originalBody;\n    } else {\n      // If we did have a challenge in memory,\n      // we attempt to load the token from the cache into the request before we try to send the request.\n      await this.loadToken(webResource);\n      response = await this._nextPolicy.sendRequest(webResource);\n    }\n\n    // If we don't receive a response with a 401 status code,\n    // then we can assume this response has nothing to do with the challenge authentication process.\n    if (response.status !== 401) {\n      return response;\n    }\n\n    // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.\n    const wwwAuthenticate = response.headers.get(\"WWW-Authenticate\");\n    if (!wwwAuthenticate) {\n      return response;\n    }\n\n    // We re-generate the challenge and see if we have to re-authenticate.\n    return await this.regenerateChallenge(wwwAuthenticate, webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\nimport { RequestOptionsBase } from \"@azure/core-http\";\nimport { DeletedKey, KeyClientInterface } from \"../../keysModels\";\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface DeleteKeyPollOperationState extends PollOperationState<DeletedKey> {\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Options for the core-http requests.\n   */\n  requestOptions?: RequestOptionsBase;\n  /**\n   * An interface representing a KeyClient. For internal use.\n   */\n  client: KeyClientInterface;\n}\n\n/**\n * An interface representing a delete key's poll operation\n */\nexport interface DeleteKeyPollOperation\n  extends PollOperation<DeleteKeyPollOperationState, DeletedKey> {}\n\n/**\n * @summary Reaches to the service and updates the delete key's poll operation.\n * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.\n */\nasync function update(\n  this: DeleteKeyPollOperation,\n  options: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: DeleteKeyPollOperationState) => void;\n  } = {}\n): Promise<DeleteKeyPollOperation> {\n  const state = this.state;\n  const { name, client } = state;\n\n  const requestOptions = state.requestOptions || {};\n  if (options.abortSignal) {\n    requestOptions.abortSignal = options.abortSignal;\n  }\n\n  if (!state.isStarted) {\n    const deletedKey = await client.deleteKey(name, requestOptions);\n    state.isStarted = true;\n    state.result = deletedKey;\n    if (!deletedKey.properties.recoveryId) {\n      state.isCompleted = true;\n    }\n  }\n\n  if (!state.isCompleted) {\n    try {\n      state.result = await client.getDeletedKey(name, { requestOptions });\n      state.isCompleted = true;\n    } catch (error) {\n      if (error.statusCode === 403) {\n        // At this point, the resource exists but the user doesn't have access to it.\n        state.isCompleted = true;\n      } else if (error.statusCode !== 404) {\n        state.error = error;\n        state.isCompleted = true;\n      }\n    }\n  }\n\n  return makeDeleteKeyPollOperation(state);\n}\n\n/**\n * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation\n * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller\n */\nasync function cancel(this: DeleteKeyPollOperation): Promise<DeleteKeyPollOperation> {\n  throw new Error(\"Canceling the deletion of a key is not supported.\");\n}\n\n/**\n * @summary Serializes the create key's poll operation\n */\nfunction toString(this: DeleteKeyPollOperation): string {\n  return JSON.stringify({\n    state: this.state\n  });\n}\n\n/**\n * @summary Builds a create key's poll operation\n * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.\n */\nexport function makeDeleteKeyPollOperation(\n  state: DeleteKeyPollOperationState\n): DeleteKeyPollOperation {\n  return {\n    state: {\n      ...state\n    },\n    update,\n    cancel,\n    toString\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, RequestOptionsBase } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\nimport { DeleteKeyPollOperationState, makeDeleteKeyPollOperation } from \"./operation\";\nimport { DeletedKey, KeyClientInterface } from \"../../keysModels\";\n\nexport interface DeleteKeyPollerOptions {\n  client: KeyClientInterface;\n  name: string;\n  requestOptions?: RequestOptionsBase;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * Class that deletes a poller that waits until a key finishes being deleted\n */\nexport class DeleteKeyPoller extends Poller<DeleteKeyPollOperationState, DeletedKey> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   * @memberof DeleteKeyPoller\n   */\n  public intervalInMs: number;\n\n  constructor(options: DeleteKeyPollerOptions) {\n    const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: DeleteKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeDeleteKeyPollOperation({\n      ...state,\n      name,\n      requestOptions,\n      client\n    });\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   * @memberof DeleteKeyPoller\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\nimport { RequestOptionsBase } from \"@azure/core-http\";\nimport { KeyVaultKey, KeyClientInterface } from \"../../keysModels\";\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface RecoverDeletedKeyPollOperationState extends PollOperationState<KeyVaultKey> {\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Options for the core-http requests.\n   */\n  requestOptions?: RequestOptionsBase;\n  /**\n   * An interface representing a KeyClient. For internal use.\n   */\n  client: KeyClientInterface;\n}\n\n/**\n * An interface representing a delete key's poll operation\n */\nexport interface RecoverDeletedKeyPollOperation\n  extends PollOperation<RecoverDeletedKeyPollOperationState, KeyVaultKey> {}\n\n/**\n * @summary Reaches to the service and updates the delete key's poll operation.\n * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.\n */\nasync function update(\n  this: RecoverDeletedKeyPollOperation,\n  options: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: RecoverDeletedKeyPollOperationState) => void;\n  } = {}\n): Promise<RecoverDeletedKeyPollOperation> {\n  const state = this.state;\n  const { name, client } = state;\n\n  const requestOptions = state.requestOptions || {};\n  if (options.abortSignal) {\n    requestOptions.abortSignal = options.abortSignal;\n  }\n\n  if (!state.isStarted) {\n    try {\n      state.result = await client.getKey(name, { requestOptions });\n      state.isCompleted = true;\n    } catch {\n      // Nothing to do here.\n    }\n    if (!state.isCompleted) {\n      state.result = await client.recoverDeletedKey(name, { requestOptions });\n      state.isStarted = true;\n    }\n  }\n\n  if (!state.isCompleted) {\n    try {\n      state.result = await client.getKey(name, { requestOptions });\n      state.isCompleted = true;\n    } catch (error) {\n      if (error.statusCode === 403) {\n        // At this point, the resource exists but the user doesn't have access to it.\n        state.isCompleted = true;\n      } else if (error.statusCode !== 404) {\n        state.error = error;\n        state.isCompleted = true;\n      }\n    }\n  }\n\n  return makeRecoverDeletedKeyPollOperation(state);\n}\n\n/**\n * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation\n * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller\n */\nasync function cancel(\n  this: RecoverDeletedKeyPollOperation\n): Promise<RecoverDeletedKeyPollOperation> {\n  throw new Error(\"Canceling the deletion of a key is not supported.\");\n}\n\n/**\n * @summary Serializes the create key's poll operation\n */\nfunction toString(this: RecoverDeletedKeyPollOperation): string {\n  return JSON.stringify({\n    state: this.state\n  });\n}\n\n/**\n * @summary Builds a create key's poll operation\n * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.\n */\nexport function makeRecoverDeletedKeyPollOperation(\n  state: RecoverDeletedKeyPollOperationState\n): RecoverDeletedKeyPollOperation {\n  return {\n    state: {\n      ...state\n    },\n    update,\n    cancel,\n    toString\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, RequestOptionsBase } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\nimport {\n  RecoverDeletedKeyPollOperationState,\n  makeRecoverDeletedKeyPollOperation\n} from \"./operation\";\nimport { KeyVaultKey, KeyClientInterface } from \"../../keysModels\";\n\nexport interface RecoverDeletedKeyPollerOptions {\n  client: KeyClientInterface;\n  name: string;\n  requestOptions?: RequestOptionsBase;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * Class that deletes a poller that waits until a key finishes being deleted\n */\nexport class RecoverDeletedKeyPoller extends Poller<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   * @memberof RecoverDeletedKeyPoller\n   */\n  public intervalInMs: number;\n\n  constructor(options: RecoverDeletedKeyPollerOptions) {\n    const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: RecoverDeletedKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeRecoverDeletedKeyPollOperation({\n      ...state,\n      name,\n      requestOptions,\n      client\n    });\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   * @memberof RecoverDeletedKeyPoller\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { DeletionRecoveryLevel } from \"./generated/models\";\n\n/**\n * Defines values for EncryptionAlgorithm.\n * Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'\n * @readonly\n * @enum {string}\n */\nexport type EncryptionAlgorithm = \"RSA-OAEP\" | \"RSA-OAEP-256\" | \"RSA1_5\";\n\n/**\n * Defines values for KeyCurveName.\n * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'\n * @readonly\n * @enum {string}\n */\nexport type KeyCurveName = \"P-256\" | \"P-384\" | \"P-521\" | \"P-256K\";\n\n/**\n * Defines values for KeyOperation.\n * Possible values include: 'encrypt', 'decrypt', 'sign', 'verify', 'wrapKey', 'unwrapKey', 'import'\n * @readonly\n * @enum {string}\n */\nexport type KeyOperation =\n  | \"encrypt\"\n  | \"decrypt\"\n  | \"sign\"\n  | \"verify\"\n  | \"wrapKey\"\n  | \"unwrapKey\"\n  | \"import\";\n\n/**\n * Defines values for KeyType.\n * Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n * @readonly\n * @enum {string}\n */\nexport type KeyType = \"EC\" | \"EC-HSM\" | \"RSA\" | \"RSA-HSM\" | \"oct\";\n\n/**\n * @internal\n * @ignore\n * An interface representing the KeyClient. For internal use.\n */\nexport interface KeyClientInterface {\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   */\n  recoverDeletedKey(name: string, options?: RecoverDeletedKeyOptions): Promise<KeyVaultKey>;\n  /**\n   * The get method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   */\n  getKey(name: string, options?: GetKeyOptions): Promise<KeyVaultKey>;\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   */\n  deleteKey(name: string, options?: DeleteKeyOptions): Promise<DeletedKey>;\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   */\n  getDeletedKey(name: string, options?: GetDeletedKeyOptions): Promise<DeletedKey>;\n}\n\n/**\n * The latest supported KeyVault service API version\n */\nexport const LATEST_API_VERSION = \"7.1\";\n\n/**\n * The optional parameters accepted by the KeyVault's KeyClient\n */\nexport interface KeyClientOptions extends coreHttp.PipelineOptions {\n  /**\n   * The accepted versions of the KeyVault's service API.\n   */\n  serviceVersion?: \"7.0\" | \"7.1\";\n}\n\n/**\n * The optional parameters accepted by the KeyVault's CryptographyClient\n */\nexport interface CryptographyClientOptions extends KeyClientOptions {}\n\n/**\n * As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18\n */\nexport interface JsonWebKey {\n  /**\n   * Key identifier.\n   */\n  kid?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   */\n  kty?: KeyType;\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * RSA modulus.\n   */\n  n?: Uint8Array;\n  /**\n   * RSA public exponent.\n   */\n  e?: Uint8Array;\n  /**\n   * RSA private exponent, or the D component of an EC private key.\n   */\n  d?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dp?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dq?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  qi?: Uint8Array;\n  /**\n   * RSA secret prime.\n   */\n  p?: Uint8Array;\n  /**\n   * RSA secret prime, with p < q.\n   */\n  q?: Uint8Array;\n  /**\n   * Symmetric key.\n   */\n  k?: Uint8Array;\n  /**\n   * HSM Token, used with 'Bring Your Own Key'.\n   */\n  t?: Uint8Array;\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName. Possible values include:\n   * 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  crv?: KeyCurveName;\n  /**\n   * X component of an EC public key.\n   */\n  x?: Uint8Array;\n  /**\n   * Y component of an EC public key.\n   */\n  y?: Uint8Array;\n}\n\n/**\n * An interface representing a KeyVault Key, with its name, value and {@link KeyProperties}.\n */\nexport interface KeyVaultKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties;\n}\n\n/**\n * An interface representing the Properties of {@link KeyVaultKey}\n */\nexport interface KeyProperties {\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of the key. May be undefined.\n   */\n  version?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Creation time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly createdOn?: Date;\n  /**\n   * Last updated time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly updatedOn?: Date;\n  /**\n   * Reflects the deletion recovery level currently in effect for keys in the current vault.\n   * If it contains 'Purgeable' the key can be permanently deleted by a privileged\n   * user; otherwise, only the system can purge the key, at the end of the\n   * retention interval. Possible values include: 'Purgeable',\n   * 'Recoverable+Purgeable', 'Recoverable',\n   * 'Recoverable+ProtectedSubscription'\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /**\n   * The retention dates of the softDelete data.\n   * The value should be >=7 and <=90 when softDelete enabled.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  recoverableDays?: number;\n}\n\n/**\n * An interface representing a deleted KeyVault Key.\n */\nexport interface DeletedKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties & {\n    /**\n     * The url of the recovery object, used to\n     * identify and recover the deleted key.\n     */\n    readonly recoveryId?: string;\n    /**\n     * The time when the key is scheduled to be purged, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    readonly scheduledPurgeDate?: Date;\n    /**\n     * The time when the key was deleted, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    deletedOn?: Date;\n  };\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createKey}\n */\nexport interface CreateKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * Size of the key\n   */\n  keySize?: number;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey} and {@link beginRecoverDeletedKey}\n */\nexport interface KeyPollerOptions extends coreHttp.OperationOptions {\n  /**\n   * Time between each polling\n   */\n  intervalInMs?: number;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey}\n */\nexport interface BeginDeleteKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginRecoverDeletedKey}\n */\nexport interface BeginRecoverDeletedKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createEcKey}\n */\nexport interface CreateEcKeyOptions extends CreateKeyOptions {\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName.\n   * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  curve?: KeyCurveName;\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hsm?: boolean;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createRsaKey}\n */\nexport interface CreateRsaKeyOptions extends CreateKeyOptions {\n  /**\n   * The key size in bits. For example: 2048, 3072, or 4096 for RSA.\n   */\n  keySize?: number;\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hsm?: boolean;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link importKey}\n */\nexport interface ImportKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hardwareProtected?: boolean;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n}\n\n/**\n * Options for {@link updateKeyProperties}.\n */\nexport interface UpdateKeyPropertiesOptions extends coreHttp.OperationOptions {\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n}\n\n/**\n * Options for {@link getKey}.\n */\nexport interface GetKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * The version of the secret to retrieve. If not\n   * specified the latest version of the secret will be retrieved.\n   */\n  version?: string;\n}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listKeys}.\n */\nexport interface ListKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeys}.\n */\nexport interface ListPropertiesOfKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeyVersions}.\n */\nexport interface ListPropertiesOfKeyVersionsOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listDeletedKeys}.\n */\nexport interface ListDeletedKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link getDeletedKey}.\n */\nexport interface GetDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link purgeDeletedKey}.\n */\nexport interface PurgeDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * @ignore\n * Options for {@link recoverDeletedKey}.\n */\nexport interface RecoverDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * @ignore\n * Options for {@link deleteKey}.\n */\nexport interface DeleteKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link backupKey}.\n */\nexport interface BackupKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link restoreKeyBackup}.\n */\nexport interface RestoreKeyBackupOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing the options of the cryptography API methods, go to the {@link CryptographyClient} for more information.\n */\nexport interface CryptographyOptions extends coreHttp.OperationOptions {}\n","import { ParsedKeyVaultEntityIdentifier } from \"./keyVaultBase\";\nimport * as url from \"url\";\n\nexport function parseKeyvaultIdentifier(\n  collection: string,\n  identifier: string | undefined\n): ParsedKeyVaultEntityIdentifier {\n  if (typeof collection != \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier != \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  var baseUri;\n  try {\n    baseUri = url.parse(identifier, true, true);\n  } catch (e) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  var segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`\n    );\n  }\n\n  var vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  var name = segments[2];\n  var version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  JsonWebKey,\n  GetKeyOptions,\n  CryptographyOptions,\n  KeyVaultKey,\n  EncryptionAlgorithm,\n  CryptographyClientOptions,\n  LATEST_API_VERSION\n} from \"./keysModels\";\nimport {\n  TokenCredential,\n  isNode,\n  createPipelineFromOptions,\n  isTokenCredential,\n  RequestOptionsBase,\n  signingPolicy,\n  operationOptionsToRequestOptionsBase\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\nimport { parseKeyvaultIdentifier } from \"./generated/utils\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\nimport { createHash as cryptoCreateHash, createVerify, publicEncrypt } from \"crypto\";\nimport * as constants from \"constants\";\n\n/**\n * A client used to perform cryptographic operations with Azure Key Vault keys.\n */\nexport class CryptographyClient {\n  /**\n   * @internal\n   * @ignore\n   * Retrieves the {@link JsonWebKey} from the Key Vault.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKey();\n   * ```\n   * @param {GetKeyOptions} [options] Options for retrieving key.\n   */\n  private async getKey(options: GetKeyOptions = {}): Promise<JsonWebKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getKey\", requestOptions);\n\n    if (typeof this.key === \"string\") {\n      if (!this.name || this.name === \"\") {\n        throw new Error(\"getKey requires a key with a name\");\n      }\n      const key = await this.client.getKey(\n        this.vaultUrl,\n        this.name,\n        options && options.version ? options.version : this.version ? this.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n      return key.key! as JsonWebKey;\n    } else {\n      return this.key;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param {EncryptionAlgorithm} algorithm The algorithm to use.\n   * @param {Uint8Array} plaintext The text to encrypt.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options: EncryptOptions = {}\n  ): Promise<EncryptResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"encrypt\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RSA1_5\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"encrypt\")) {\n              span.end();\n              throw new Error(\"Key does not support the encrypt operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const padded: any = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };\n            const encrypted = publicEncrypt(padded, Buffer.from(plaintext));\n            return { result: encrypted, algorithm, keyID: this.key.kid };\n          }\n          case \"RSA-OAEP\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"encrypt\")) {\n              span.end();\n              throw new Error(\"Key does not support the encrypt operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const encrypted = publicEncrypt(keyPEM, Buffer.from(plaintext));\n            return { result: encrypted, algorithm, keyID: this.key.kid };\n          }\n        }\n      }\n    }\n\n    // Default to the service\n    let result;\n    try {\n      result = await this.client.encrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        plaintext,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   * @param {EncryptionAlgorithm} algorithm The algorithm to use.\n   * @param {Uint8Array} ciphertext The text to decrypt.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n\n  public async decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options: DecryptOptions = {}\n  ): Promise<DecryptResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"decrypt\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.decrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        ciphertext,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, keyID: this.getKeyID(), algorithm };\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.\n   * @param {Uint8Array} key The key to wrap.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"wrapKey\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RSA1_5\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"wrapKey\")) {\n              span.end();\n              throw new Error(\"Key does not support the wrapKey operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const padded: any = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };\n            const encrypted = publicEncrypt(padded, Buffer.from(key));\n            return { result: encrypted, algorithm, keyID: this.getKeyID() };\n          }\n          case \"RSA-OAEP\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              span.end();\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"wrapKey\")) {\n              span.end();\n              throw new Error(\"Key does not support the wrapKey operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const encrypted = publicEncrypt(keyPEM, Buffer.from(key));\n            return { result: encrypted, algorithm, keyID: this.getKeyID() };\n          }\n        }\n      }\n    }\n\n    // Default to the service\n    let result;\n    try {\n      result = await this.client.wrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        key,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.\n   * @param {Uint8Array} encryptedKey The encrypted key to unwrap.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"unwrapKey\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.unwrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        encryptedKey,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.\n   * @param {Uint8Array} digest The digest of the data to sign.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"sign\", requestOptions);\n\n    let result;\n    try {\n      result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.\n   * @param {Uint8Array} digest The digest to verify.\n   * @param {Uint8Array} signature The signature to verify the digest against.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"verify\", requestOptions);\n\n    let response;\n    try {\n      response = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: response.value ? response.value : false, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.\n   * @param {Uint8Array} data The data to sign.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"signData\", requestOptions);\n\n    let digest;\n    switch (algorithm) {\n      case \"ES256\":\n      case \"ES256K\":\n      case \"PS256\":\n      case \"RS256\":\n        {\n          digest = await createHash(\"sha256\", data);\n        }\n        break;\n      case \"ES384\":\n      case \"PS384\":\n      case \"RS384\":\n        {\n          digest = await createHash(\"sha384\", data);\n        }\n        break;\n      case \"ES512\":\n      case \"PS512\":\n      case \"RS512\":\n        {\n          digest = await createHash(\"sha512\", data);\n        }\n        break;\n      default: {\n        throw new Error(\"Unsupported signature algorithm\");\n      }\n    }\n\n    let result;\n    try {\n      result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.result!, algorithm, keyID: this.getKeyID() };\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.\n   * @param {Uint8Array} data The signed block of data to verify.\n   * @param {Uint8Array} signature The signature to verify the block against.\n   * @param {EncryptOptions} [options] Additional options.\n   */\n  public async verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"verifyData\", requestOptions);\n\n    if (isNode) {\n      await this.fetchFullKeyIfPossible();\n\n      if (typeof this.key !== \"string\") {\n        switch (algorithm) {\n          case \"RS256\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA256\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n          case \"RS384\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA384\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n          case \"RS512\": {\n            if (this.key.kty !== \"RSA\" && this.key.kty !== \"RSA-HSM\") {\n              throw new Error(\"Key type does not match algorithm\");\n            }\n\n            if (this.key.keyOps && !this.key.keyOps.includes(\"verify\")) {\n              throw new Error(\"Key does not support the verify operation\");\n            }\n\n            const keyPEM = convertJWKtoPEM(this.key);\n\n            const verifier = createVerify(\"SHA512\");\n            verifier.update(Buffer.from(data));\n            verifier.end();\n\n            return {\n              result: verifier.verify(keyPEM, Buffer.from(signature)),\n              keyID: this.getKeyID()\n            };\n          }\n        }\n      }\n    }\n\n    let digest: Buffer;\n    switch (algorithm) {\n      case \"ES256\":\n      case \"ES256K\":\n      case \"PS256\":\n      case \"RS256\":\n        {\n          digest = await createHash(\"sha256\", data);\n        }\n        break;\n      case \"ES384\":\n      case \"PS384\":\n      case \"RS384\":\n        {\n          digest = await createHash(\"sha384\", data);\n        }\n        break;\n      case \"ES512\":\n      case \"PS512\":\n      case \"RS512\":\n        {\n          digest = await createHash(\"sha512\", data);\n        }\n        break;\n      default: {\n        throw new Error(\"Unsupported signature algorithm\");\n      }\n    }\n\n    let result;\n    try {\n      result = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return { result: result.value!, keyID: this.getKeyID() };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Attempts to fetch the key from the service.\n   */\n  private async fetchFullKeyIfPossible(): Promise<void> {\n    if (!this.hasTriedToGetKey) {\n      try {\n        this.key = await this.getKey();\n      } catch {\n        // Nothing to do here.\n      }\n      this.hasTriedToGetKey = true;\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.kid;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor, it can be either a string with the URL of a KeyVault Key, or an already parsed {@link JsonWebKey}.\n   */\n  private key: string | JsonWebKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Has the client tried to fetch the full key yet\n   */\n  private hasTriedToGetKey: boolean;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.\n   *                                                         Omit this parameter to use the default pipeline configuration.\n   * @memberof CryptographyClient\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n\n    let parsed;\n    if (typeof key === \"string\") {\n      this.key = key;\n      parsed = parseKeyvaultIdentifier(\"keys\", this.key);\n      this.hasTriedToGetKey = false;\n    } else if (key.key) {\n      this.key = key.key;\n      parsed = parseKeyvaultIdentifier(\"keys\", this.key.kid!);\n      this.hasTriedToGetKey = true;\n    } else {\n      throw new Error(\n        \"The provided key is malformed as it does not have a value for the `key` property.\"\n      );\n    }\n\n    if (parsed.name === \"\") {\n      throw new Error(\"Could not find 'name' of key in key URL\");\n    }\n\n    if (!parsed.version || parsed.version === \"\") {\n      throw new Error(\"Could not find 'version' of key in key URL\");\n    }\n\n    if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n      throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n    }\n\n    this.vaultUrl = parsed.vaultUrl;\n    this.name = parsed.name;\n    this.version = parsed.version;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user.\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions?: RequestOptionsBase): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(\n      `CryptographyClient ${methodName}`,\n      requestOptions && requestOptions.spanOptions\n    );\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Encodes a length of a packet in DER format\n */\nfunction encodeLength(length: number): Uint8Array {\n  if (length <= 127) {\n    return Uint8Array.of(length);\n  } else if (length < 256) {\n    return Uint8Array.of(0x81, length);\n  } else if (length < 65536) {\n    return Uint8Array.of(0x82, length >> 8, length & 0xff);\n  } else {\n    throw new Error(\"Unsupported length to encode\");\n  }\n}\n\n/**\n * @internal\n * @ignore\n * Encodes a buffer for DER, as sets the id to the given id\n */\nfunction encodeBuffer(buffer: Uint8Array, bufferId: number): Uint8Array {\n  if (buffer.length === 0) {\n    return buffer;\n  }\n\n  let result = new Uint8Array(buffer);\n\n  // If the high bit is set, prepend a 0\n  if ((result[0] & 0x80) === 0x80) {\n    const array = new Uint8Array(result.length + 1);\n    array[0] = 0;\n    array.set(result, 1);\n    result = array;\n  }\n\n  // Prepend the DER header for this buffer\n  const encodedLength = encodeLength(result.length);\n\n  const totalLength = 1 + encodedLength.length + result.length;\n\n  const outputBuffer = new Uint8Array(totalLength);\n  outputBuffer[0] = bufferId;\n  outputBuffer.set(encodedLength, 1);\n  outputBuffer.set(result, 1 + encodedLength.length);\n\n  return outputBuffer;\n}\n\n/**\n * @internal\n * @ignore\n * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER\n * that is then encoded as a PEM.\n */\nexport function convertJWKtoPEM(key: JsonWebKey): string {\n  if (!key.n || !key.e) {\n    throw new Error(\"Unsupported key format for local operations\");\n  }\n  const encoded_n = encodeBuffer(key.n, 0x2); // INTEGER\n  const encoded_e = encodeBuffer(key.e, 0x2); // INTEGER\n\n  const encoded_ne = new Uint8Array(encoded_n.length + encoded_e.length);\n  encoded_ne.set(encoded_n, 0);\n  encoded_ne.set(encoded_e, encoded_n.length);\n\n  const full_encoded = encodeBuffer(encoded_ne, 0x30); // SEQUENCE\n\n  const buffer = Buffer.from(full_encoded).toString(\"base64\");\n\n  const beginBanner = \"-----BEGIN RSA PUBLIC KEY-----\\n\";\n  const endBanner = \"-----END RSA PUBLIC KEY-----\";\n\n  /*\n   Fill in the PEM with 64 character lines as per RFC:\n\n   \"To represent the encapsulated text of a PEM message, the encoding\n   function's output is delimited into text lines (using local\n   conventions), with each line except the last containing exactly 64\n   printable characters and the final line containing 64 or fewer\n   printable characters.\"\n  */\n  let outputString = beginBanner;\n  const lines = buffer.match(/.{1,64}/g);\n\n  if (lines) {\n    for (const line of lines) {\n      outputString += line;\n      outputString += \"\\n\";\n    }\n  } else {\n    throw new Error(\"Could not create correct PEM\");\n  }\n  outputString += endBanner;\n\n  return outputString;\n}\n\n/**\n * @internal\n * @ignore\n * Use the platform-local hashing functionality\n */\nasync function createHash(algorithm: string, data: Uint8Array): Promise<Buffer> {\n  if (isNode) {\n    const hash = cryptoCreateHash(algorithm);\n    hash.update(Buffer.from(data));\n    const digest = hash.digest();\n    return digest;\n  } else {\n    if (window && window.crypto && window.crypto.subtle) {\n      return Buffer.from(await window.crypto.subtle.digest(algorithm, Buffer.from(data)));\n    } else {\n      throw new Error(\"Browser does not support cryptography functions\");\n    }\n  }\n}\n\n/**\n * Supported algorithms for key wrapping/unwrapping\n */\nexport type KeyWrapAlgorithm = \"RSA-OAEP\" | \"RSA-OAEP-256\" | \"RSA1_5\";\n\n/**\n * Defines values for SignatureAlgorithm.\n * Possible values include: 'PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512',\n * 'ES256', 'ES384', 'ES512', 'ES256K'\n * @readonly\n * @enum {string}\n */\nexport type SignatureAlgorithm =\n  | \"PS256\"\n  | \"PS384\"\n  | \"PS512\"\n  | \"RS256\"\n  | \"RS384\"\n  | \"RS512\"\n  | \"ES256\"\n  | \"ES384\"\n  | \"ES512\"\n  | \"ES256K\";\n\n/**\n * Options for {@link encrypt}.\n */\nexport interface EncryptOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link decrypt}.\n */\nexport interface DecryptOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link sign}.\n */\nexport interface SignOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link verify}.\n */\nexport interface VerifyOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link wrapKey}.\n */\nexport interface WrapKeyOptions extends CryptographyOptions {}\n\n/**\n * Options for {@link unwrapKey}.\n */\nexport interface UnwrapKeyOptions extends CryptographyOptions {}\n\n/**\n * Result of the {@link decrypt} operation.\n */\nexport interface DecryptResult {\n  /**\n   * Result of the {@link decrypt} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to decrypt the encrypted data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to decrypt the encrypted data.\n   */\n  algorithm: EncryptionAlgorithm;\n}\n\n/**\n * Result of the {@link encrypt} operation.\n */\nexport interface EncryptResult {\n  /**\n   * Result of the {@link encrypt} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The {@link EncryptionAlgorithm} used to encrypt the data.\n   */\n  algorithm: EncryptionAlgorithm;\n  /**\n   * The ID of the KeyVault Key used to encrypt the data.\n   */\n  keyID?: string;\n}\n\n/**\n * Result of the {@link sign} operation.\n */\nexport interface SignResult {\n  /**\n   * Result of the {@link sign} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to sign the data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to sign the data.\n   */\n  algorithm: SignatureAlgorithm;\n}\n\n/**\n * Result of the {@link verify} operation.\n */\nexport interface VerifyResult {\n  /**\n   * Result of the {@link verify} operation in bytes.\n   */\n  result: boolean;\n  /**\n   * The ID of the KeyVault Key used to verify the data.\n   */\n  keyID?: string;\n}\n\n/**\n * Result of the {@link wrap} operation.\n */\nexport interface WrapResult {\n  /**\n   * Result of the {@link wrap} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to wrap the data.\n   */\n  keyID?: string;\n  /**\n   * The {@link EncryptionAlgorithm} used to wrap the data.\n   */\n  algorithm: KeyWrapAlgorithm;\n}\n\n/**\n * Result of the {@link unwrap} operation.\n */\nexport interface UnwrapResult {\n  /**\n   * Result of the {@link unwrap} operation in bytes.\n   */\n  result: Uint8Array;\n  /**\n   * The ID of the KeyVault Key used to unwrap the data.\n   */\n  keyID?: string;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  PipelineOptions,\n  RequestOptionsBase,\n  TokenCredential,\n  createPipelineFromOptions,\n  isTokenCredential,\n  operationOptionsToRequestOptionsBase,\n  signingPolicy\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  BackupKeyResponse,\n  CreateKeyResponse,\n  DeleteKeyResponse,\n  DeletedKeyBundle,\n  DeletionRecoveryLevel,\n  GetDeletedKeyResponse,\n  GetKeyResponse,\n  ImportKeyResponse,\n  KeyBundle,\n  KeyItem,\n  KeyVaultClientGetKeysOptionalParams,\n  RecoverDeletedKeyResponse,\n  RestoreKeyResponse,\n  UpdateKeyResponse\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteKeyPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedKeyPoller } from \"./lro/recover/poller\";\n\nimport {\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyOptions,\n  DeletedKey,\n  DeleteKeyOptions,\n  EncryptionAlgorithm,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyClientInterface,\n  KeyCurveName,\n  KeyOperation,\n  KeyPollerOptions,\n  KeyType,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  KeyVaultKey,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PurgeDeletedKeyOptions,\n  RecoverDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  UpdateKeyPropertiesOptions,\n  KeyClientOptions,\n  LATEST_API_VERSION,\n  CryptographyClientOptions\n} from \"./keysModels\";\nimport { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from \"./generated/utils\";\n\nimport {\n  CryptographyClient,\n  DecryptOptions,\n  DecryptResult,\n  EncryptOptions,\n  EncryptResult,\n  SignatureAlgorithm,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult\n} from \"./cryptographyClient\";\n\nexport {\n  CryptographyClientOptions,\n  KeyClientOptions,\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyClient,\n  CryptographyOptions,\n  DecryptOptions,\n  DecryptResult,\n  DeletedKey,\n  DeletionRecoveryLevel,\n  EncryptOptions,\n  EncryptResult,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyCurveName,\n  EncryptionAlgorithm,\n  KeyOperation,\n  KeyType,\n  KeyPollerOptions,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  SignatureAlgorithm,\n  KeyVaultKey,\n  KeyWrapAlgorithm,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PageSettings,\n  PagedAsyncIterableIterator,\n  PipelineOptions,\n  PollOperationState,\n  PollerLike,\n  PurgeDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  UpdateKeyPropertiesOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n  logger\n};\n\n/**\n * The KeyClient provides methods to manage {@link KeyVaultKey} in the\n * Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultKeys. The\n * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key\n * Vault.\n */\nexport class KeyClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * @internal\n   * @ignore\n   * A self reference that bypasses private methods, for the pollers.\n   */\n  private readonly pollerClient: KeyClientInterface = {\n    recoverDeletedKey: this.recoverDeletedKey.bind(this),\n    getKey: this.getKey.bind(this),\n    deleteKey: this.deleteKey.bind(this),\n    getDeletedKey: this.getDeletedKey.bind(this)\n  };\n\n  /**\n   * Creates an instance of KeyClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new KeyClient(vaultUrl, credentials);\n   * ```\n   * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.\n   * @memberof KeyClient\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: KeyClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a delete request for the given KeyVault Key's name to the KeyVault service.\n   * Since the KeyVault Key won't be immediately deleted, we have {@link beginDeleteKey}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {DeleteKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async deleteKey(name: string, options: DeleteKeyOptions = {}): Promise<DeletedKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"deleteKey\", requestOptions);\n\n    let response: DeleteKeyResponse;\n    try {\n      response = await this.client.deleteKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a request to recover a deleted KeyVault Key based on the given name.\n   * Since the KeyVault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async recoverDeletedKey(\n    name: string,\n    options: RecoverDeletedKeyOptions = {}\n  ): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"recoverDeletedKey\", requestOptions);\n\n    let response: RecoverDeletedKeyResponse;\n    try {\n      response = await this.client.recoverDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Create an elliptic-curve key:\n   * let result = await client.createKey(\"MyKey\", \"EC\");\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {KeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.\n   * @param {CreateKeyOptions} [options] The optional parameters.\n   */\n  public async createKey(\n    name: string,\n    keyType: KeyType,\n    options?: CreateKeyOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          keyType,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, keyType, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createEcKey(\"MyKey\", { curve: \"P-256\" });\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {CreateEcKeyOptions} [options] The optional parameters.\n   */\n  public async createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createEcKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          options.hsm ? \"EC-HSM\" : \"EC\",\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, \"EC\", options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createRsaKey(\"MyKey\", { keySize: 2048 });\n   * ```\n   * @summary Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param {string} name The name of the key.\n   * @param {CreateRsaKeyOptions} [options] The optional parameters.\n   */\n  public async createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"createRsaKey\", unflattenedOptions);\n\n      let response: CreateKeyResponse;\n      try {\n        response = await this.client.createKey(\n          this.vaultUrl,\n          name,\n          options.hsm ? \"RSA-HSM\" : \"RSA\",\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.createKey(this.vaultUrl, name, \"RSA\", options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Key contents in myKeyContents\n   * let result = await client.importKey(\"MyKey\", myKeyContents);\n   * ```\n   * @summary Imports an externally created key, stores it, and returns key parameters and properties\n   * to the client.\n   * @param {string} name Name for the imported key.\n   * @param {JsonWebKey} key The JSON web key.\n   * @param {ImportKeyOptions} [options] The optional parameters.\n   */\n  public async importKey(\n    name: string,\n    key: JsonWebKey,\n    options?: ImportKeyOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const {\n        enabled,\n        notBefore,\n        expiresOn: expires,\n        hardwareProtected: hsm,\n        ...remainingOptions\n      } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          hsm\n        }\n      };\n\n      const span = this.createSpan(\"importKey\", unflattenedOptions);\n\n      let response: ImportKeyResponse;\n      try {\n        response = await this.client.importKey(\n          this.vaultUrl,\n          name,\n          key,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.importKey(this.vaultUrl, name, key, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.\n   *\n   * This operation requires the keys/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const poller = await client.beginDeleteKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginDeleteKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedKey = await poller.pollUntilDone();\n   * console.log(deletedKey);\n   * ```\n   * @summary Deletes a key from a specified key vault.\n   * @param {string} name The name of the key.\n   * @param {BeginDeleteKeyOptions} [options] The optional parameters.\n   */\n  public async beginDeleteKey(\n    name: string,\n    options: BeginDeleteKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const poller = new DeleteKeyPoller({\n      name,\n      client: this.pollerClient,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      requestOptions\n    });\n\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n\n    return poller;\n  }\n\n  /**\n   * The updateKeyProperties method changes specified properties of an existing stored key. Properties that\n   * are not specified in the request are left unchanged. The value of a key itself cannot be\n   * changed. This operation requires the keys/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let keyName = \"MyKey\";\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(keyName);\n   * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });\n   * ```\n   * @summary Updates the properties associated with a specified key in a given key vault.\n   * @param {string} name The name of the key.\n   * @param {string} keyVersion The version of the key.\n   * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.\n   */\n  public async updateKeyProperties(\n    name: string,\n    keyVersion: string,\n    options?: UpdateKeyPropertiesOptions\n  ): Promise<KeyVaultKey> {\n    if (options) {\n      const requestOptions = operationOptionsToRequestOptionsBase(options);\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"updateKeyProperties\", unflattenedOptions);\n\n      let response: UpdateKeyResponse;\n\n      try {\n        response = await this.client.updateKey(\n          this.vaultUrl,\n          name,\n          keyVersion,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getKeyFromKeyBundle(response);\n    } else {\n      const response = await this.client.updateKey(this.vaultUrl, name, keyVersion, options);\n      return this.getKeyFromKeyBundle(response);\n    }\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(\"MyKey\");\n   * ```\n   * @summary Get a specified key from a given key vault.\n   * @param {string} name The name of the key.\n   * @param {GetKeyOptions} [options] The optional parameters.\n   */\n  public async getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getKey\", requestOptions);\n\n    let response: GetKeyResponse;\n    try {\n      response = await this.client.getKey(\n        this.vaultUrl,\n        name,\n        options && options.version ? options.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getDeletedKey(\"MyDeletedKey\");\n   * ```\n   * @summary Gets the specified deleted key.\n   * @param {string} name The name of the key.\n   * @param {GetDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async getDeletedKey(\n    name: string,\n    options: GetDeletedKeyOptions = {}\n  ): Promise<DeletedKey> {\n    const responseOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getDeletedKey\", responseOptions);\n\n    let response: GetDeletedKeyResponse;\n    try {\n      response = await this.client.getDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, responseOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * The purge deleted key operation removes the key permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the keys/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\")\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedKey(\"MyKey\");\n   * ```\n   * @summary Permanently deletes the specified key.\n   * @param name The name of the key.\n   * @param {PurgeDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async purgeDeletedKey(name: string, options: PurgeDeletedKeyOptions = {}): Promise<void> {\n    const responseOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"purgeDeletedKey\", responseOptions);\n\n    try {\n      await this.client.purgeDeletedKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, responseOptions)\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.\n   *\n   * This operation requires the keys/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\");\n   * await deletePoller.pollUntilDone();\n   * const poller = await client.beginRecoverDeletedKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginRecoverDeletedKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const key = await poller.pollUntilDone();\n   * console.log(key);\n   * ```\n   * @summary Recovers the deleted key to the latest version.\n   * @param name The name of the deleted key.\n   * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.\n   */\n  public async beginRecoverDeletedKey(\n    name: string,\n    options: BeginRecoverDeletedKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    const poller = new RecoverDeletedKeyPoller({\n      name,\n      client: this.pollerClient,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      requestOptions: requestOptions\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified key be downloaded to the client. All versions of the\n   * key will be downloaded. This operation requires the keys/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * ```\n   * @summary Backs up the specified key.\n   * @param {string} name The name of the key.\n   * @param {BackupKeyOptions} [options] The optional parameters.\n   */\n  public async backupKey(\n    name: string,\n    options: BackupKeyOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"backupKey\", requestOptions);\n\n    let response: BackupKeyResponse;\n    try {\n      response = await this.client.backupKey(\n        this.vaultUrl,\n        name,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return response.value;\n  }\n\n  /**\n   * Restores a backed up key, and all its versions, to a vault. This operation requires the\n   * keys/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * // ...\n   * let key = await client.restoreKeyBackup(backupContents);\n   * ```\n   * @summary Restores a backed up key to a vault.\n   * @param {Uint8Array} backup The backup blob associated with a key bundle.\n   * @param {RestoreKeyBackupOptions} [options] The optional parameters.\n   */\n  public async restoreKeyBackup(\n    backup: Uint8Array,\n    options: RestoreKeyBackupOptions = {}\n  ): Promise<KeyVaultKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"restoreKeyBackup\", requestOptions);\n\n    let response: RestoreKeyResponse;\n    try {\n      response = await this.client.restoreKey(\n        this.vaultUrl,\n        backup,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getKeyFromKeyBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfKeyVersions}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsPage(\n    name: string,\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getKeyVersions(\n        this.vaultUrl,\n        name,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getKeyVersions(\n        continuationState.continuationToken,\n        name,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.\n   * @param {string} name The name of the KeyVault Key.\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsAll(\n    name: string,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeyVersionsPage(name, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided\n   * in the response. This operation requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeyVersions(\"MyKey\")) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key version: \", key);\n   * }\n   * ```\n   * @param {string} name Name of the key to fetch versions for\n   * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfKeyVersions(\n    name: string,\n    options: ListPropertiesOfKeyVersionsOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfKeyVersions\", requestOptions);\n    const updatedOptions: ListPropertiesOfKeyVersionsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfKeyVersionsAll(name, updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeyVersionsPage(name, settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfKeys}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysPage(\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getKeys(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getKeys(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.\n   * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysAll(\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeys()) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key: \", key);\n   * }\n   * ```\n   * @summary List all keys in the vault\n   * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfKeys(\n    options: ListPropertiesOfKeysOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfKeys\", requestOptions);\n    const updatedOptions: ListPropertiesOfKeysOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfKeysAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeysPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listDeletedKeys}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysPage(\n    continuationState: PageSettings,\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getDeletedKeys(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getDeletedKeyFromKeyItem);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getDeletedKeys(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(this.getDeletedKeyFromKeyItem);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listDeletedKeys}.\n   * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysAll(\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey> {\n    const f = {};\n\n    for await (const page of this.listDeletedKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const deletedKey of client.listDeletedKeys()) {\n   *   console.log(\"deleted key: \", deletedKey);\n   * }\n   * ```\n   * @summary List all keys in the vault\n   * @param {ListDeletedKeysOptions} [options] The optional parameters.\n   */\n  public listDeletedKeys(\n    options: ListDeletedKeysOptions = {}\n  ): PagedAsyncIterableIterator<DeletedKey> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listDeletedKeys\", requestOptions);\n\n    const updatedOptions: ListDeletedKeysOptions = {\n      ...options,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listDeletedKeysAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedKeysPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.\n   */\n  private getKeyFromKeyBundle(bundle: KeyBundle | DeletedKeyBundle): KeyVaultKey {\n    const keyBundle = bundle as KeyBundle;\n    const deletedKeyBundle = bundle as DeletedKeyBundle;\n\n    const parsedId = parseKeyvaultEntityIdentifier(\n      \"keys\",\n      keyBundle.key ? keyBundle.key.kid : undefined\n    );\n\n    const attributes: any = keyBundle.attributes || {};\n    delete keyBundle.attributes;\n\n    const resultObject: KeyVaultKey & DeletedKey = {\n      key: keyBundle.key as JsonWebKey,\n      id: keyBundle.key ? keyBundle.key.kid : undefined,\n      name: parsedId.name,\n      keyOperations: keyBundle.key ? (keyBundle.key.keyOps as KeyOperation[]) : undefined,\n      keyType: keyBundle.key ? keyBundle.key.kty : undefined,\n      properties: {\n        id: keyBundle.key ? keyBundle.key.kid : undefined,\n        expiresOn: attributes.expires,\n        createdOn: attributes.created,\n        updatedOn: attributes.updated,\n        ...keyBundle,\n        ...parsedId,\n        ...attributes\n      }\n    };\n\n    if (deletedKeyBundle.deletedDate) {\n      resultObject.properties.deletedOn = deletedKeyBundle.deletedDate;\n      delete (resultObject.properties as any).deletedDate;\n    }\n\n    if (attributes.vaultUrl) {\n      delete (resultObject.properties as any).vaultUrl;\n    }\n    if (attributes.expires) {\n      delete (resultObject.properties as any).expires;\n    }\n    if (attributes.created) {\n      delete (resultObject.properties as any).created;\n    }\n    if (attributes.updated) {\n      delete (resultObject.properties as any).updated;\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link DeletedKey} based on a received KeyItem.\n   */\n  private getDeletedKeyFromKeyItem(keyItem: KeyItem): DeletedKey {\n    const parsedId = parseKeyvaultEntityIdentifier(\"keys\", keyItem.kid);\n\n    const attributes = keyItem.attributes || {};\n\n    const abstractProperties: any = {\n      id: keyItem.kid,\n      deletedOn: (attributes as any).deletedDate,\n      expiresOn: attributes.expires,\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      ...keyItem,\n      ...parsedId,\n      ...keyItem.attributes\n    };\n\n    if (abstractProperties.deletedDate) {\n      delete abstractProperties.deletedDate;\n    }\n\n    if (abstractProperties.expires) {\n      delete abstractProperties.expires;\n    }\n    if (abstractProperties.created) {\n      delete abstractProperties.created;\n    }\n    if (abstractProperties.updated) {\n      delete abstractProperties.updated;\n    }\n\n    return {\n      key: keyItem,\n      id: keyItem.kid,\n      name: abstractProperties.name,\n      properties: abstractProperties\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyProperties} based on a received KeyItem.\n   */\n  private getKeyPropertiesFromKeyItem(keyItem: KeyItem): KeyProperties {\n    const parsedId = parseKeyvaultEntityIdentifier(\"keys\", keyItem.kid);\n\n    const attributes = keyItem.attributes || {};\n\n    const resultObject: any = {\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      ...keyItem,\n      ...parsedId,\n      ...keyItem.attributes\n    };\n\n    delete resultObject.attributes;\n\n    if (keyItem.attributes!.expires) {\n      resultObject.expiresOn = keyItem.attributes!.expires;\n      delete resultObject.expires;\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user.\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions?: RequestOptionsBase): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n"],"names":["createClientLogger","coreHttp.ServiceClient","coreHttp.getDefaultUserAgentValue","coreHttp.Serializer","Parameters.vaultBaseUrl","Parameters.keyName0","Parameters.apiVersion","Mappers.KeyCreateParameters","Mappers.KeyBundle","Mappers.KeyVaultError","Mappers.KeyImportParameters","Parameters.keyName1","Mappers.DeletedKeyBundle","Parameters.keyVersion","Mappers.KeyUpdateParameters","Parameters.maxresults","Mappers.KeyListResult","Mappers.BackupKeyResult","Mappers.KeyRestoreParameters","Mappers.KeyOperationsParameters","Mappers.KeyOperationResult","Mappers.KeySignParameters","Mappers.KeyVerifyParameters","Mappers.KeyVerifyResult","Mappers.DeletedKeyListResult","ExpiringAccessTokenCache","BaseRequestPolicy","Constants","Poller","delay","update","cancel","toString","url.parse","isTokenCredential","signingPolicy","createPipelineFromOptions","operationOptionsToRequestOptionsBase","constants.RSA_PKCS1_PADDING","publicEncrypt","createVerify","getTracer","cryptoCreateHash","__asyncValues","parseKeyvaultEntityIdentifier"],"mappings":"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"}