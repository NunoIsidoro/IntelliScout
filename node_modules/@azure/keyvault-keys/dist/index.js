/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Keys SDK for JavaScript - 4.1.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
require('@azure/core-paging');
var coreLro = require('@azure/core-lro');
var url = require('url');
var crypto = require('crypto');
var constants = require('constants');

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("keyvault-keys");

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const JsonWebKey = {
    serializedName: "JsonWebKey",
    type: {
        name: "Composite",
        className: "JsonWebKey",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            n: {
                serializedName: "n",
                type: {
                    name: "Base64Url"
                }
            },
            e: {
                serializedName: "e",
                type: {
                    name: "Base64Url"
                }
            },
            d: {
                serializedName: "d",
                type: {
                    name: "Base64Url"
                }
            },
            dp: {
                serializedName: "dp",
                type: {
                    name: "Base64Url"
                }
            },
            dq: {
                serializedName: "dq",
                type: {
                    name: "Base64Url"
                }
            },
            qi: {
                serializedName: "qi",
                type: {
                    name: "Base64Url"
                }
            },
            p: {
                serializedName: "p",
                type: {
                    name: "Base64Url"
                }
            },
            q: {
                serializedName: "q",
                type: {
                    name: "Base64Url"
                }
            },
            k: {
                serializedName: "k",
                type: {
                    name: "Base64Url"
                }
            },
            t: {
                serializedName: "key_hsm",
                type: {
                    name: "Base64Url"
                }
            },
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "Base64Url"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const Attributes = {
    serializedName: "Attributes",
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const KeyAttributes = {
    serializedName: "KeyAttributes",
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: Object.assign(Object.assign({}, Attributes.type.modelProperties), { recoverableDays: {
                readOnly: true,
                serializedName: "recoverableDays",
                type: {
                    name: "Number"
                }
            }, recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
const KeyBundle = {
    serializedName: "KeyBundle",
    type: {
        name: "Composite",
        className: "KeyBundle",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const KeyItem = {
    serializedName: "KeyItem",
    type: {
        name: "Composite",
        className: "KeyItem",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DeletedKeyBundle = {
    serializedName: "DeletedKeyBundle",
    type: {
        name: "Composite",
        className: "DeletedKeyBundle",
        modelProperties: Object.assign(Object.assign({}, KeyBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
const DeletedKeyItem = {
    serializedName: "DeletedKeyItem",
    type: {
        name: "Composite",
        className: "DeletedKeyItem",
        modelProperties: Object.assign(Object.assign({}, KeyItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
const KeyProperties = {
    serializedName: "KeyProperties",
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            },
            keyType: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            reuseKey: {
                serializedName: "reuse_key",
                type: {
                    name: "Boolean"
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyCreateParameters = {
    serializedName: "KeyCreateParameters",
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            kty: {
                required: true,
                serializedName: "kty",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyImportParameters = {
    serializedName: "KeyImportParameters",
    type: {
        name: "Composite",
        className: "KeyImportParameters",
        modelProperties: {
            hsm: {
                serializedName: "Hsm",
                type: {
                    name: "Boolean"
                }
            },
            key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const KeyOperationsParameters = {
    serializedName: "KeyOperationsParameters",
    type: {
        name: "Composite",
        className: "KeyOperationsParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const KeySignParameters = {
    serializedName: "KeySignParameters",
    type: {
        name: "Composite",
        className: "KeySignParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const KeyVerifyParameters = {
    serializedName: "KeyVerifyParameters",
    type: {
        name: "Composite",
        className: "KeyVerifyParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            digest: {
                required: true,
                serializedName: "digest",
                type: {
                    name: "Base64Url"
                }
            },
            signature: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const KeyUpdateParameters = {
    serializedName: "KeyUpdateParameters",
    type: {
        name: "Composite",
        className: "KeyUpdateParameters",
        modelProperties: {
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const KeyRestoreParameters = {
    serializedName: "KeyRestoreParameters",
    type: {
        name: "Composite",
        className: "KeyRestoreParameters",
        modelProperties: {
            keyBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const KeyOperationResult = {
    serializedName: "KeyOperationResult",
    type: {
        name: "Composite",
        className: "KeyOperationResult",
        modelProperties: {
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            result: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const KeyVerifyResult = {
    serializedName: "KeyVerifyResult",
    type: {
        name: "Composite",
        className: "KeyVerifyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const KeyListResult = {
    serializedName: "KeyListResult",
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedKeyListResult = {
    serializedName: "DeletedKeyListResult",
    type: {
        name: "Composite",
        className: "DeletedKeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedKeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupKeyResult = {
    serializedName: "BackupKeyResult",
    type: {
        name: "Composite",
        className: "BackupKeyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innerError: {
                readOnly: true,
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const KeyVaultError = {
    serializedName: "KeyVaultError",
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                readOnly: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    JsonWebKey: JsonWebKey,
    Attributes: Attributes,
    KeyAttributes: KeyAttributes,
    KeyBundle: KeyBundle,
    KeyItem: KeyItem,
    DeletedKeyBundle: DeletedKeyBundle,
    DeletedKeyItem: DeletedKeyItem,
    KeyProperties: KeyProperties,
    KeyCreateParameters: KeyCreateParameters,
    KeyImportParameters: KeyImportParameters,
    KeyOperationsParameters: KeyOperationsParameters,
    KeySignParameters: KeySignParameters,
    KeyVerifyParameters: KeyVerifyParameters,
    KeyUpdateParameters: KeyUpdateParameters,
    KeyRestoreParameters: KeyRestoreParameters,
    KeyOperationResult: KeyOperationResult,
    KeyVerifyResult: KeyVerifyResult,
    KeyListResult: KeyListResult,
    DeletedKeyListResult: DeletedKeyListResult,
    BackupKeyResult: BackupKeyResult,
    ErrorModel: ErrorModel,
    KeyVaultError: KeyVaultError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const keyName0 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
const keyName1 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        type: {
            name: "String"
        }
    }
};
const keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        required: true,
        serializedName: "key-version",
        type: {
            name: "String"
        }
    }
};
const maxresults = {
    parameterPath: [
        "options",
        "maxresults"
    ],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
const vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        required: true,
        serializedName: "vaultBaseUrl",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const packageName = "@azure/keyvault-keys";
const packageVersion = "4.1.0";
class KeyVaultClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the KeyVaultClientContext class.
     * @param apiVersion Client API version.
     * @param [options] The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.baseUri = "{vaultBaseUrl}";
        this.requestContentType = "application/json; charset=utf-8";
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class KeyVaultClient extends KeyVaultClientContext {
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param apiVersion Client API version.
     * @param [options] The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
    }
    createKey(vaultBaseUrl, keyName, kty, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            kty,
            options
        }, createKeyOperationSpec, callback);
    }
    importKey(vaultBaseUrl, keyName, key, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            key,
            options
        }, importKeyOperationSpec, callback);
    }
    deleteKey(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, deleteKeyOperationSpec, callback);
    }
    updateKey(vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            options
        }, updateKeyOperationSpec, callback);
    }
    getKey(vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            options
        }, getKeyOperationSpec, callback);
    }
    getKeyVersions(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, getKeyVersionsOperationSpec, callback);
    }
    getKeys(vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            options
        }, getKeysOperationSpec, callback);
    }
    backupKey(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, backupKeyOperationSpec, callback);
    }
    restoreKey(vaultBaseUrl, keyBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyBundleBackup,
            options
        }, restoreKeyOperationSpec, callback);
    }
    encrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            value,
            options
        }, encryptOperationSpec, callback);
    }
    decrypt(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            value,
            options
        }, decryptOperationSpec, callback);
    }
    sign(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            value,
            options
        }, signOperationSpec, callback);
    }
    verify(vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            digest,
            signature,
            options
        }, verifyOperationSpec, callback);
    }
    wrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            value,
            options
        }, wrapKeyOperationSpec, callback);
    }
    unwrapKey(vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            keyVersion,
            algorithm,
            value,
            options
        }, unwrapKeyOperationSpec, callback);
    }
    getDeletedKeys(vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            options
        }, getDeletedKeysOperationSpec, callback);
    }
    getDeletedKey(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, getDeletedKeyOperationSpec, callback);
    }
    purgeDeletedKey(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, purgeDeletedKeyOperationSpec, callback);
    }
    recoverDeletedKey(vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            keyName,
            options
        }, recoverDeletedKeyOperationSpec, callback);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers);
const createKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/create",
    urlParameters: [
        vaultBaseUrl,
        keyName0
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            kty: "kty",
            keySize: [
                "options",
                "keySize"
            ],
            keyOps: [
                "options",
                "keyOps"
            ],
            keyAttributes: [
                "options",
                "keyAttributes"
            ],
            tags: [
                "options",
                "tags"
            ],
            curve: [
                "options",
                "curve"
            ]
        },
        mapper: Object.assign(Object.assign({}, KeyCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const importKeyOperationSpec = {
    httpMethod: "PUT",
    path: "keys/{key-name}",
    urlParameters: [
        vaultBaseUrl,
        keyName0
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            hsm: [
                "options",
                "hsm"
            ],
            key: "key",
            keyAttributes: [
                "options",
                "keyAttributes"
            ],
            tags: [
                "options",
                "tags"
            ]
        },
        mapper: Object.assign(Object.assign({}, KeyImportParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const deleteKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "keys/{key-name}",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const updateKeyOperationSpec = {
    httpMethod: "PATCH",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            keyOps: [
                "options",
                "keyOps"
            ],
            keyAttributes: [
                "options",
                "keyAttributes"
            ],
            tags: [
                "options",
                "tags"
            ]
        },
        mapper: Object.assign(Object.assign({}, KeyUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getKeyOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getKeyVersionsOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/versions",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getKeysOperationSpec = {
    httpMethod: "GET",
    path: "keys",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const backupKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/backup",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: BackupKeyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const restoreKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/restore",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            keyBundleBackup: "keyBundleBackup"
        },
        mapper: Object.assign(Object.assign({}, KeyRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const encryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/encrypt",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: Object.assign(Object.assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const decryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/decrypt",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: Object.assign(Object.assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const signOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/sign",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: Object.assign(Object.assign({}, KeySignParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const verifyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/verify",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            digest: "digest",
            signature: "signature"
        },
        mapper: Object.assign(Object.assign({}, KeyVerifyParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyVerifyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const wrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/wrapkey",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: Object.assign(Object.assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const unwrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/unwrapkey",
    urlParameters: [
        vaultBaseUrl,
        keyName1,
        keyVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: Object.assign(Object.assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getDeletedKeysOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedKeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getDeletedKeyOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys/{key-name}",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const purgeDeletedKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedkeys/{key-name}",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const recoverDeletedKeyOperationSpec = {
    httpMethod: "POST",
    path: "deletedkeys/{key-name}/recover",
    urlParameters: [
        vaultBaseUrl,
        keyName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
const SDK_VERSION = "4.1.0";

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Representation of the Authentication Challenge
 */
class AuthenticationChallenge {
    constructor(authorization, scope) {
        this.authorization = authorization;
        this.scope = scope;
    }
    /**
     * Checks that this AuthenticationChallenge is equal to another one given.
     * Only compares the scope.
     * This is exactly what C# is doing, as we can see here:
     * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147
     * @param other The other AuthenticationChallenge
     */
    equalTo(other) {
        return other
            ? this.scope.toLowerCase() === other.scope.toLowerCase() &&
                this.authorization.toLowerCase() === other.authorization.toLowerCase()
            : false;
    }
}
/**
 * Helps keep a copy of any previous authentication challenges,
 * so that we can compare on any further request.
 */
class AuthenticationChallengeCache {
    setCachedChallenge(challenge) {
        this.challenge = challenge;
    }
}
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    const tokenCache = new coreHttp.ExpiringAccessTokenCache();
    const challengeCache = new AuthenticationChallengeCache();
    return {
        create: (nextPolicy, options) => {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache, challengeCache);
        },
    };
}
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="some_authorization", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "some_authorization", resource: "https://some.url" }`
 * @param wwwAuthenticate string value in the WWW-Authenticate header
 */
function parseWWWAuthenticate(wwwAuthenticate) {
    // First we split the string by either `, ` or ` `.
    const parts = wwwAuthenticate.split(/,* +/);
    // Then we only keep the strings with an equal sign after a word and before a quote.
    // also splitting these sections by their equal sign
    const keyValues = parts.reduce((parts, str) => (str.match(/\w="/) ? [...parts, str.split("=")] : parts), []);
    // Then we transform these key-value pairs back into an object.
    const parsed = keyValues.reduce((result, [key, value]) => (Object.assign(Object.assign({}, result), { [key]: value.slice(1, -1) })), {});
    return parsed;
}
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
class ChallengeBasedAuthenticationPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.
     */
    constructor(nextPolicy, options, credential, tokenCache, challengeCache) {
        super(nextPolicy, options);
        this.credential = credential;
        this.tokenCache = tokenCache;
        this.challengeCache = challengeCache;
        this.parseWWWAuthenticate = parseWWWAuthenticate;
    }
    /**
     * Gets or updates the token from the token cache into the headers of the received web resource.
     */
    loadToken(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let accessToken = this.tokenCache.getCachedToken();
            // If there's no cached token in the cache, we try to get a new one.
            if (accessToken === undefined) {
                const receivedToken = yield this.credential.getToken(this.challengeCache.challenge.scope);
                accessToken = receivedToken || undefined;
                this.tokenCache.setCachedToken(accessToken);
            }
            if (accessToken) {
                webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
            }
        });
    }
    /**
     * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,
     * then if the challenge is different from the one cached, resets the token and forces
     * a re-authentication, otherwise continues with the existing challenge and token.
     * @param wwwAuthenticate Value of the incoming WWW-Authenticate header.
     * @param webResource Ongoing HTTP request.
     */
    regenerateChallenge(wwwAuthenticate, webResource) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // The challenge based authentication will contain both:
            // - An authorization URI with a token,
            // - The resource to which that token is valid against (also called the scope).
            const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);
            const authorization = parsedWWWAuth.authorization;
            const resource = parsedWWWAuth.resource || parsedWWWAuth.scope;
            if (!(authorization && resource)) {
                return this._nextPolicy.sendRequest(webResource);
            }
            const challenge = new AuthenticationChallenge(authorization, resource + "/.default");
            // Either if there's no cached challenge at this point (could have happen in parallel),
            // or if the cached challenge has a different scope,
            // we store the just received challenge and reset the cached token, to force a re-authentication.
            if (!((_a = this.challengeCache.challenge) === null || _a === void 0 ? void 0 : _a.equalTo(challenge))) {
                this.challengeCache.setCachedChallenge(challenge);
                this.tokenCache.setCachedToken(undefined);
            }
            yield this.loadToken(webResource);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource Ongoing HTTP request.
     */
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Ensure that we're about to use a secure connection.
            if (!webResource.url.startsWith("https:")) {
                throw new Error("The resource address for authorization must use the 'https' protocol.");
            }
            // The next request will happen differently whether we have a challenge or not.
            let response;
            if (this.challengeCache.challenge == undefined) {
                // If there's no challenge in cache, a blank body will start the challenge.
                const originalBody = webResource.body;
                webResource.body = "";
                response = yield this._nextPolicy.sendRequest(webResource);
                webResource.body = originalBody;
            }
            else {
                // If we did have a challenge in memory,
                // we attempt to load the token from the cache into the request before we try to send the request.
                yield this.loadToken(webResource);
                response = yield this._nextPolicy.sendRequest(webResource);
            }
            // If we don't receive a response with a 401 status code,
            // then we can assume this response has nothing to do with the challenge authentication process.
            if (response.status !== 401) {
                return response;
            }
            // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.
            const wwwAuthenticate = response.headers.get("WWW-Authenticate");
            if (!wwwAuthenticate) {
                return response;
            }
            // We re-generate the challenge and see if we have to re-authenticate.
            return yield this.regenerateChallenge(wwwAuthenticate, webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete key's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update(options = {}) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const state = this.state;
        const { name, client } = state;
        const requestOptions = state.requestOptions || {};
        if (options.abortSignal) {
            requestOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            const deletedKey = yield client.deleteKey(name, requestOptions);
            state.isStarted = true;
            state.result = deletedKey;
            if (!deletedKey.properties.recoveryId) {
                state.isCompleted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = yield client.getDeletedKey(name, { requestOptions });
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                }
            }
        }
        return makeDeleteKeyPollOperation(state);
    });
}
/**
 * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel() {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        throw new Error("Canceling the deletion of a key is not supported.");
    });
}
/**
 * @summary Serializes the create key's poll operation
 */
function toString() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create key's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeDeleteKeyPollOperation(state) {
    return {
        state: Object.assign({}, state),
        update,
        cancel,
        toString
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a key finishes being deleted
 */
class DeleteKeyPoller extends coreLro.Poller {
    constructor(options) {
        const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeDeleteKeyPollOperation(Object.assign(Object.assign({}, state), { name,
            requestOptions,
            client }));
        super(operation);
        this.intervalInMs = intervalInMs;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof DeleteKeyPoller
     */
    delay() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return coreHttp.delay(this.intervalInMs);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete key's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update$1(options = {}) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const state = this.state;
        const { name, client } = state;
        const requestOptions = state.requestOptions || {};
        if (options.abortSignal) {
            requestOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            try {
                state.result = yield client.getKey(name, { requestOptions });
                state.isCompleted = true;
            }
            catch (_a) {
                // Nothing to do here.
            }
            if (!state.isCompleted) {
                state.result = yield client.recoverDeletedKey(name, { requestOptions });
                state.isStarted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = yield client.getKey(name, { requestOptions });
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                }
            }
        }
        return makeRecoverDeletedKeyPollOperation(state);
    });
}
/**
 * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel$1() {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        throw new Error("Canceling the deletion of a key is not supported.");
    });
}
/**
 * @summary Serializes the create key's poll operation
 */
function toString$1() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create key's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeRecoverDeletedKeyPollOperation(state) {
    return {
        state: Object.assign({}, state),
        update: update$1,
        cancel: cancel$1,
        toString: toString$1
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a key finishes being deleted
 */
class RecoverDeletedKeyPoller extends coreLro.Poller {
    constructor(options) {
        const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeRecoverDeletedKeyPollOperation(Object.assign(Object.assign({}, state), { name,
            requestOptions,
            client }));
        super(operation);
        this.intervalInMs = intervalInMs;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof RecoverDeletedKeyPoller
     */
    delay() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return coreHttp.delay(this.intervalInMs);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The latest supported KeyVault service API version
 */
const LATEST_API_VERSION = "7.1";

function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection != "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier != "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    var baseUri;
    try {
        baseUri = url.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);
    }
    // Path is of the form '/collection/name[/version]'
    var segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`);
    }
    if (collection !== segments[1]) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. segment [1] should be "${collection}", found "${segments[1]}"`);
    }
    var vaultUrl = `${baseUri.protocol}//${baseUri.host}`;
    var name = segments[2];
    var version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl,
        name,
        version
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * A client used to perform cryptographic operations with Azure Key Vault keys.
 */
class CryptographyClient {
    /**
     * Constructs a new instance of the Cryptography client for the given key
     *
     * Example usage:
     * ```ts
     * import { KeyClient, CryptographyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let keyClient = new KeyClient(vaultUrl, credentials);
     * let keyVaultKey = await keyClient.getKey("MyKey");
     *
     * let client = new CryptographyClient(keyVaultKey.id, credentials);
     * // or
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * ```
     * @param key The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof CryptographyClient
     */
    constructor(key, credential, pipelineOptions = {}) {
        const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;
        const userAgentOptions = pipelineOptions.userAgentOptions;
        pipelineOptions.userAgentOptions = Object.assign(Object.assign({}, pipelineOptions.userAgentOptions), { userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix
                ? `${userAgentOptions.userAgentPrefix} ${libInfo}`
                : libInfo });
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, pipeline);
        let parsed;
        if (typeof key === "string") {
            this.key = key;
            parsed = parseKeyvaultIdentifier("keys", this.key);
            this.hasTriedToGetKey = false;
        }
        else if (key.key) {
            this.key = key.key;
            parsed = parseKeyvaultIdentifier("keys", this.key.kid);
            this.hasTriedToGetKey = true;
        }
        else {
            throw new Error("The provided key is malformed as it does not have a value for the `key` property.");
        }
        if (parsed.name === "") {
            throw new Error("Could not find 'name' of key in key URL");
        }
        if (!parsed.version || parsed.version === "") {
            throw new Error("Could not find 'version' of key in key URL");
        }
        if (!parsed.vaultUrl || parsed.vaultUrl === "") {
            throw new Error("Could not find 'vaultUrl' of key in key URL");
        }
        this.vaultUrl = parsed.vaultUrl;
        this.name = parsed.name;
        this.version = parsed.version;
    }
    /**
     * @internal
     * @ignore
     * Retrieves the {@link JsonWebKey} from the Key Vault.
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.getKey();
     * ```
     * @param {GetKeyOptions} [options] Options for retrieving key.
     */
    getKey(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getKey", requestOptions);
            if (typeof this.key === "string") {
                if (!this.name || this.name === "") {
                    throw new Error("getKey requires a key with a name");
                }
                const key = yield this.client.getKey(this.vaultUrl, this.name, options && options.version ? options.version : this.version ? this.version : "", this.setParentSpan(span, requestOptions));
                return key.key;
            }
            else {
                return this.key;
            }
        });
    }
    /**
     * Encrypts the given plaintext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.encrypt("RSA1_5", Buffer.from("My Message"));
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} plaintext The text to encrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    encrypt(algorithm, plaintext, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("encrypt", requestOptions);
            {
                yield this.fetchFullKeyIfPossible();
                if (typeof this.key !== "string") {
                    switch (algorithm) {
                        case "RSA1_5": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                span.end();
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                span.end();
                                throw new Error("Key does not support the encrypt operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                            const encrypted = crypto.publicEncrypt(padded, Buffer.from(plaintext));
                            return { result: encrypted, algorithm, keyID: this.key.kid };
                        }
                        case "RSA-OAEP": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                span.end();
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                span.end();
                                throw new Error("Key does not support the encrypt operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const encrypted = crypto.publicEncrypt(keyPEM, Buffer.from(plaintext));
                            return { result: encrypted, algorithm, keyID: this.key.kid };
                        }
                    }
                }
            }
            // Default to the service
            let result;
            try {
                result = yield this.client.encrypt(this.vaultUrl, this.name, this.version, algorithm, plaintext, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, algorithm, keyID: this.getKeyID() };
        });
    }
    /**
     * Decrypts the given ciphertext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.decrypt("RSA1_5", encryptedBuffer);
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} ciphertext The text to decrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    decrypt(algorithm, ciphertext, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("decrypt", requestOptions);
            let result;
            try {
                result = yield this.client.decrypt(this.vaultUrl, this.name, this.version, algorithm, ciphertext, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, keyID: this.getKeyID(), algorithm };
        });
    }
    /**
     * Wraps the given key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.wrapKey("RSA1_5", keyToWrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.
     * @param {Uint8Array} key The key to wrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    wrapKey(algorithm, key, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("wrapKey", requestOptions);
            {
                yield this.fetchFullKeyIfPossible();
                if (typeof this.key !== "string") {
                    switch (algorithm) {
                        case "RSA1_5": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                span.end();
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                span.end();
                                throw new Error("Key does not support the wrapKey operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                            const encrypted = crypto.publicEncrypt(padded, Buffer.from(key));
                            return { result: encrypted, algorithm, keyID: this.getKeyID() };
                        }
                        case "RSA-OAEP": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                span.end();
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                span.end();
                                throw new Error("Key does not support the wrapKey operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const encrypted = crypto.publicEncrypt(keyPEM, Buffer.from(key));
                            return { result: encrypted, algorithm, keyID: this.getKeyID() };
                        }
                    }
                }
            }
            // Default to the service
            let result;
            try {
                result = yield this.client.wrapKey(this.vaultUrl, this.name, this.version, algorithm, key, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, algorithm, keyID: this.getKeyID() };
        });
    }
    /**
     * Unwraps the given wrapped key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.unwrapKey("RSA1_5", keyToUnwrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.
     * @param {Uint8Array} encryptedKey The encrypted key to unwrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    unwrapKey(algorithm, encryptedKey, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("unwrapKey", requestOptions);
            let result;
            try {
                result = yield this.client.unwrapKey(this.vaultUrl, this.name, this.version, algorithm, encryptedKey, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, keyID: this.getKeyID() };
        });
    }
    /**
     * Cryptographically sign the digest of a message
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.sign("RS256", digest);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} digest The digest of the data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    sign(algorithm, digest, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("sign", requestOptions);
            let result;
            try {
                result = yield this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, algorithm, keyID: this.getKeyID() };
        });
    }
    /**
     * Verify the signed message digest
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verify("RS256", signedDigest, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.
     * @param {Uint8Array} digest The digest to verify.
     * @param {Uint8Array} signature The signature to verify the digest against.
     * @param {EncryptOptions} [options] Additional options.
     */
    verify(algorithm, digest, signature, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("verify", requestOptions);
            let response;
            try {
                response = yield this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: response.value ? response.value : false, keyID: this.getKeyID() };
        });
    }
    /**
     * Cryptographically sign a block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.signData("RS256", message);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} data The data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    signData(algorithm, data, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("signData", requestOptions);
            let digest;
            switch (algorithm) {
                case "ES256":
                case "ES256K":
                case "PS256":
                case "RS256":
                    {
                        digest = yield createHash("sha256", data);
                    }
                    break;
                case "ES384":
                case "PS384":
                case "RS384":
                    {
                        digest = yield createHash("sha384", data);
                    }
                    break;
                case "ES512":
                case "PS512":
                case "RS512":
                    {
                        digest = yield createHash("sha512", data);
                    }
                    break;
                default: {
                    throw new Error("Unsupported signature algorithm");
                }
            }
            let result;
            try {
                result = yield this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.result, algorithm, keyID: this.getKeyID() };
        });
    }
    /**
     * Verify the signed block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verifyData("RS256", signedMessage, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.
     * @param {Uint8Array} data The signed block of data to verify.
     * @param {Uint8Array} signature The signature to verify the block against.
     * @param {EncryptOptions} [options] Additional options.
     */
    verifyData(algorithm, data, signature, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("verifyData", requestOptions);
            {
                yield this.fetchFullKeyIfPossible();
                if (typeof this.key !== "string") {
                    switch (algorithm) {
                        case "RS256": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                throw new Error("Key does not support the verify operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const verifier = crypto.createVerify("SHA256");
                            verifier.update(Buffer.from(data));
                            verifier.end();
                            return {
                                result: verifier.verify(keyPEM, Buffer.from(signature)),
                                keyID: this.getKeyID()
                            };
                        }
                        case "RS384": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                throw new Error("Key does not support the verify operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const verifier = crypto.createVerify("SHA384");
                            verifier.update(Buffer.from(data));
                            verifier.end();
                            return {
                                result: verifier.verify(keyPEM, Buffer.from(signature)),
                                keyID: this.getKeyID()
                            };
                        }
                        case "RS512": {
                            if (this.key.kty !== "RSA" && this.key.kty !== "RSA-HSM") {
                                throw new Error("Key type does not match algorithm");
                            }
                            if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                throw new Error("Key does not support the verify operation");
                            }
                            const keyPEM = convertJWKtoPEM(this.key);
                            const verifier = crypto.createVerify("SHA512");
                            verifier.update(Buffer.from(data));
                            verifier.end();
                            return {
                                result: verifier.verify(keyPEM, Buffer.from(signature)),
                                keyID: this.getKeyID()
                            };
                        }
                    }
                }
            }
            let digest;
            switch (algorithm) {
                case "ES256":
                case "ES256K":
                case "PS256":
                case "RS256":
                    {
                        digest = yield createHash("sha256", data);
                    }
                    break;
                case "ES384":
                case "PS384":
                case "RS384":
                    {
                        digest = yield createHash("sha384", data);
                    }
                    break;
                case "ES512":
                case "PS512":
                case "RS512":
                    {
                        digest = yield createHash("sha512", data);
                    }
                    break;
                default: {
                    throw new Error("Unsupported signature algorithm");
                }
            }
            let result;
            try {
                result = yield this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return { result: result.value, keyID: this.getKeyID() };
        });
    }
    /**
     * @internal
     * @ignore
     * Attempts to fetch the key from the service.
     */
    fetchFullKeyIfPossible() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.hasTriedToGetKey) {
                try {
                    this.key = yield this.getKey();
                }
                catch (_a) {
                    // Nothing to do here.
                }
                this.hasTriedToGetKey = true;
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Attempts to retrieve the ID of the key.
     */
    getKeyID() {
        let kid;
        if (typeof this.key !== "string") {
            kid = this.key.kid;
        }
        else {
            kid = this.key;
        }
        return kid;
    }
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    createSpan(methodName, requestOptions) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan(`CryptographyClient ${methodName}`, requestOptions && requestOptions.spanOptions);
        span.setAttribute("az.namespace", "Microsoft.KeyVault");
        return span;
    }
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    setParentSpan(span, options = {}) {
        if (span.isRecording()) {
            const spanOptions = options.spanOptions || {};
            return Object.assign(Object.assign({}, options), { spanOptions: Object.assign(Object.assign({}, spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.KeyVault" }) }) });
        }
        else {
            return options;
        }
    }
}
/**
 * @internal
 * @ignore
 * Encodes a length of a packet in DER format
 */
function encodeLength(length) {
    if (length <= 127) {
        return Uint8Array.of(length);
    }
    else if (length < 256) {
        return Uint8Array.of(0x81, length);
    }
    else if (length < 65536) {
        return Uint8Array.of(0x82, length >> 8, length & 0xff);
    }
    else {
        throw new Error("Unsupported length to encode");
    }
}
/**
 * @internal
 * @ignore
 * Encodes a buffer for DER, as sets the id to the given id
 */
function encodeBuffer(buffer, bufferId) {
    if (buffer.length === 0) {
        return buffer;
    }
    let result = new Uint8Array(buffer);
    // If the high bit is set, prepend a 0
    if ((result[0] & 0x80) === 0x80) {
        const array = new Uint8Array(result.length + 1);
        array[0] = 0;
        array.set(result, 1);
        result = array;
    }
    // Prepend the DER header for this buffer
    const encodedLength = encodeLength(result.length);
    const totalLength = 1 + encodedLength.length + result.length;
    const outputBuffer = new Uint8Array(totalLength);
    outputBuffer[0] = bufferId;
    outputBuffer.set(encodedLength, 1);
    outputBuffer.set(result, 1 + encodedLength.length);
    return outputBuffer;
}
/**
 * @internal
 * @ignore
 * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER
 * that is then encoded as a PEM.
 */
function convertJWKtoPEM(key) {
    if (!key.n || !key.e) {
        throw new Error("Unsupported key format for local operations");
    }
    const encoded_n = encodeBuffer(key.n, 0x2); // INTEGER
    const encoded_e = encodeBuffer(key.e, 0x2); // INTEGER
    const encoded_ne = new Uint8Array(encoded_n.length + encoded_e.length);
    encoded_ne.set(encoded_n, 0);
    encoded_ne.set(encoded_e, encoded_n.length);
    const full_encoded = encodeBuffer(encoded_ne, 0x30); // SEQUENCE
    const buffer = Buffer.from(full_encoded).toString("base64");
    const beginBanner = "-----BEGIN RSA PUBLIC KEY-----\n";
    const endBanner = "-----END RSA PUBLIC KEY-----";
    /*
     Fill in the PEM with 64 character lines as per RFC:
  
     "To represent the encapsulated text of a PEM message, the encoding
     function's output is delimited into text lines (using local
     conventions), with each line except the last containing exactly 64
     printable characters and the final line containing 64 or fewer
     printable characters."
    */
    let outputString = beginBanner;
    const lines = buffer.match(/.{1,64}/g);
    if (lines) {
        for (const line of lines) {
            outputString += line;
            outputString += "\n";
        }
    }
    else {
        throw new Error("Could not create correct PEM");
    }
    outputString += endBanner;
    return outputString;
}
/**
 * @internal
 * @ignore
 * Use the platform-local hashing functionality
 */
function createHash(algorithm, data) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        {
            const hash = crypto.createHash(algorithm);
            hash.update(Buffer.from(data));
            const digest = hash.digest();
            return digest;
        }
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * The KeyClient provides methods to manage {@link KeyVaultKey} in the
 * Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultKeys. The
 * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key
 * Vault.
 */
class KeyClient {
    /**
     * Creates an instance of KeyClient.
     *
     * Example usage:
     * ```ts
     * import { KeyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new KeyClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.
     * @memberof KeyClient
     */
    constructor(vaultUrl, credential, pipelineOptions = {}) {
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedKey: this.recoverDeletedKey.bind(this),
            getKey: this.getKey.bind(this),
            deleteKey: this.deleteKey.bind(this),
            getDeletedKey: this.getDeletedKey.bind(this)
        };
        this.vaultUrl = vaultUrl;
        const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;
        const userAgentOptions = pipelineOptions.userAgentOptions;
        pipelineOptions.userAgentOptions = Object.assign(Object.assign({}, pipelineOptions.userAgentOptions), { userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix
                ? `${userAgentOptions.userAgentPrefix} ${libInfo}`
                : libInfo });
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, pipeline);
    }
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Key's name to the KeyVault service.
     * Since the KeyVault Key won't be immediately deleted, we have {@link beginDeleteKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {DeleteKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    deleteKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("deleteKey", requestOptions);
            let response;
            try {
                response = yield this.client.deleteKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getKeyFromKeyBundle(response);
        });
    }
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Key based on the given name.
     * Since the KeyVault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    recoverDeletedKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("recoverDeletedKey", requestOptions);
            let response;
            try {
                response = yield this.client.recoverDeletedKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getKeyFromKeyBundle(response);
        });
    }
    /**
     * The create key operation can be used to create any key type in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Create an elliptic-curve key:
     * let result = await client.createKey("MyKey", "EC");
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {KeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.
     * @param {CreateKeyOptions} [options] The optional parameters.
     */
    createKey(name, keyType, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { keyAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("createKey", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.createKey(this.vaultUrl, name, keyType, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getKeyFromKeyBundle(response);
            }
            else {
                const response = yield this.client.createKey(this.vaultUrl, name, keyType, options);
                return this.getKeyFromKeyBundle(response);
            }
        });
    }
    /**
     * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createEcKey("MyKey", { curve: "P-256" });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateEcKeyOptions} [options] The optional parameters.
     */
    createEcKey(name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { keyAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("createEcKey", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.createKey(this.vaultUrl, name, options.hsm ? "EC-HSM" : "EC", this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getKeyFromKeyBundle(response);
            }
            else {
                const response = yield this.client.createKey(this.vaultUrl, name, "EC", options);
                return this.getKeyFromKeyBundle(response);
            }
        });
    }
    /**
     * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createRsaKey("MyKey", { keySize: 2048 });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateRsaKeyOptions} [options] The optional parameters.
     */
    createRsaKey(name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { keyAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("createRsaKey", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.createKey(this.vaultUrl, name, options.hsm ? "RSA-HSM" : "RSA", this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getKeyFromKeyBundle(response);
            }
            else {
                const response = yield this.client.createKey(this.vaultUrl, name, "RSA", options);
                return this.getKeyFromKeyBundle(response);
            }
        });
    }
    /**
     * The import key operation may be used to import any key type into an Azure Key Vault. If the
     * named key already exists, Azure Key Vault creates a new version of the key. This operation
     * requires the keys/import permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Key contents in myKeyContents
     * let result = await client.importKey("MyKey", myKeyContents);
     * ```
     * @summary Imports an externally created key, stores it, and returns key parameters and properties
     * to the client.
     * @param {string} name Name for the imported key.
     * @param {JsonWebKey} key The JSON web key.
     * @param {ImportKeyOptions} [options] The optional parameters.
     */
    importKey(name, key, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                const { enabled, notBefore, expiresOn: expires, hardwareProtected: hsm } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn", "hardwareProtected"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { keyAttributes: {
                        enabled,
                        notBefore,
                        expires,
                        hsm
                    } });
                const span = this.createSpan("importKey", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.importKey(this.vaultUrl, name, key, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getKeyFromKeyBundle(response);
            }
            else {
                const response = yield this.client.importKey(this.vaultUrl, name, key, options);
                return this.getKeyFromKeyBundle(response);
            }
        });
    }
    /**
     * The delete operation applies to any key stored in Azure Key Vault. Individual versions
     * of a key can not be deleted, only all versions of a given key at once.
     *
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.
     *
     * This operation requires the keys/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const poller = await client.beginDeleteKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginDeleteKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedKey = await poller.pollUntilDone();
     * console.log(deletedKey);
     * ```
     * @summary Deletes a key from a specified key vault.
     * @param {string} name The name of the key.
     * @param {BeginDeleteKeyOptions} [options] The optional parameters.
     */
    beginDeleteKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const poller = new DeleteKeyPoller({
                name,
                client: this.pollerClient,
                intervalInMs: options.intervalInMs,
                resumeFrom: options.resumeFrom,
                requestOptions
            });
            // This will initialize the poller's operation (the deletion of the key).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The updateKeyProperties method changes specified properties of an existing stored key. Properties that
     * are not specified in the request are left unchanged. The value of a key itself cannot be
     * changed. This operation requires the keys/set permission.
     *
     * Example usage:
     * ```ts
     * let keyName = "MyKey";
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey(keyName);
     * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });
     * ```
     * @summary Updates the properties associated with a specified key in a given key vault.
     * @param {string} name The name of the key.
     * @param {string} keyVersion The version of the key.
     * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.
     */
    updateKeyProperties(name, keyVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (options) {
                const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { keyAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("updateKeyProperties", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.updateKey(this.vaultUrl, name, keyVersion, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getKeyFromKeyBundle(response);
            }
            else {
                const response = yield this.client.updateKey(this.vaultUrl, name, keyVersion, options);
                return this.getKeyFromKeyBundle(response);
            }
        });
    }
    /**
     * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey("MyKey");
     * ```
     * @summary Get a specified key from a given key vault.
     * @param {string} name The name of the key.
     * @param {GetKeyOptions} [options] The optional parameters.
     */
    getKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getKey", requestOptions);
            let response;
            try {
                response = yield this.client.getKey(this.vaultUrl, name, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getKeyFromKeyBundle(response);
        });
    }
    /**
     * The getDeletedKey method returns the specified deleted key along with its properties.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getDeletedKey("MyDeletedKey");
     * ```
     * @summary Gets the specified deleted key.
     * @param {string} name The name of the key.
     * @param {GetDeletedKeyOptions} [options] The optional parameters.
     */
    getDeletedKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const responseOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getDeletedKey", responseOptions);
            let response;
            try {
                response = yield this.client.getDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions));
            }
            finally {
                span.end();
            }
            return this.getKeyFromKeyBundle(response);
        });
    }
    /**
     * The purge deleted key operation removes the key permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the keys/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * const deletePoller = await client.beginDeleteKey("MyKey")
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedKey("MyKey");
     * ```
     * @summary Permanently deletes the specified key.
     * @param name The name of the key.
     * @param {PurgeDeletedKeyOptions} [options] The optional parameters.
     */
    purgeDeletedKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const responseOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("purgeDeletedKey", responseOptions);
            try {
                yield this.client.purgeDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions));
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Recovers the deleted key in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault.
     *
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.
     *
     * This operation requires the keys/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const deletePoller = await client.beginDeleteKey("MyKey");
     * await deletePoller.pollUntilDone();
     * const poller = await client.beginRecoverDeletedKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginRecoverDeletedKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const key = await poller.pollUntilDone();
     * console.log(key);
     * ```
     * @summary Recovers the deleted key to the latest version.
     * @param name The name of the deleted key.
     * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.
     */
    beginRecoverDeletedKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const poller = new RecoverDeletedKeyPoller({
                name,
                client: this.pollerClient,
                intervalInMs: options.intervalInMs,
                resumeFrom: options.resumeFrom,
                requestOptions: requestOptions
            });
            // This will initialize the poller's operation (the deletion of the key).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Requests that a backup of the specified key be downloaded to the client. All versions of the
     * key will be downloaded. This operation requires the keys/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * ```
     * @summary Backs up the specified key.
     * @param {string} name The name of the key.
     * @param {BackupKeyOptions} [options] The optional parameters.
     */
    backupKey(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("backupKey", requestOptions);
            let response;
            try {
                response = yield this.client.backupKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return response.value;
        });
    }
    /**
     * Restores a backed up key, and all its versions, to a vault. This operation requires the
     * keys/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * // ...
     * let key = await client.restoreKeyBackup(backupContents);
     * ```
     * @summary Restores a backed up key to a vault.
     * @param {Uint8Array} backup The backup blob associated with a key bundle.
     * @param {RestoreKeyBackupOptions} [options] The optional parameters.
     */
    restoreKeyBackup(backup, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("restoreKeyBackup", requestOptions);
            let response;
            try {
                response = yield this.client.restoreKey(this.vaultUrl, backup, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getKeyFromKeyBundle(response);
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    listPropertiesOfKeyVersionsPage(name, continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfKeyVersionsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getKeyVersions(this.vaultUrl, name, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getKeyVersions(continuationState.continuationToken, name, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    listPropertiesOfKeyVersionsAll(name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfKeyVersionsAll_1() {
            var e_1, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfKeyVersionsPage(name, f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided
     * in the response. This operation requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeyVersions("MyKey")) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key version: ", key);
     * }
     * ```
     * @param {string} name Name of the key to fetch versions for
     * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.
     */
    listPropertiesOfKeyVersions(name, options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfKeyVersions", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfKeyVersionsAll(name, updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfKeyVersionsPage(name, settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    listPropertiesOfKeysPage(continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfKeysPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getKeys(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getKeys(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    listPropertiesOfKeysAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfKeysAll_1() {
            var e_2, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfKeysPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeys()) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key: ", key);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.
     */
    listPropertiesOfKeys(options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfKeys", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfKeysAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfKeysPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    listDeletedKeysPage(continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedKeysPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getDeletedKeys(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getDeletedKeys(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedKeys}.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    listDeletedKeysAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedKeysAll_1() {
            var e_3, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listDeletedKeysPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Iterates the deleted keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const deletedKey of client.listDeletedKeys()) {
     *   console.log("deleted key: ", deletedKey);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListDeletedKeysOptions} [options] The optional parameters.
     */
    listDeletedKeys(options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listDeletedKeys", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, options), this.setParentSpan(span, requestOptions));
        const iter = this.listDeletedKeysAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listDeletedKeysPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.
     */
    getKeyFromKeyBundle(bundle) {
        const keyBundle = bundle;
        const deletedKeyBundle = bundle;
        const parsedId = parseKeyvaultIdentifier("keys", keyBundle.key ? keyBundle.key.kid : undefined);
        const attributes = keyBundle.attributes || {};
        delete keyBundle.attributes;
        const resultObject = {
            key: keyBundle.key,
            id: keyBundle.key ? keyBundle.key.kid : undefined,
            name: parsedId.name,
            keyOperations: keyBundle.key ? keyBundle.key.keyOps : undefined,
            keyType: keyBundle.key ? keyBundle.key.kty : undefined,
            properties: Object.assign(Object.assign(Object.assign({ id: keyBundle.key ? keyBundle.key.kid : undefined, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, keyBundle), parsedId), attributes)
        };
        if (deletedKeyBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedKeyBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes.vaultUrl) {
            delete resultObject.properties.vaultUrl;
        }
        if (attributes.expires) {
            delete resultObject.properties.expires;
        }
        if (attributes.created) {
            delete resultObject.properties.created;
        }
        if (attributes.updated) {
            delete resultObject.properties.updated;
        }
        return resultObject;
    }
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link DeletedKey} based on a received KeyItem.
     */
    getDeletedKeyFromKeyItem(keyItem) {
        const parsedId = parseKeyvaultIdentifier("keys", keyItem.kid);
        const attributes = keyItem.attributes || {};
        const abstractProperties = Object.assign(Object.assign(Object.assign({ id: keyItem.kid, deletedOn: attributes.deletedDate, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, keyItem), parsedId), keyItem.attributes);
        if (abstractProperties.deletedDate) {
            delete abstractProperties.deletedDate;
        }
        if (abstractProperties.expires) {
            delete abstractProperties.expires;
        }
        if (abstractProperties.created) {
            delete abstractProperties.created;
        }
        if (abstractProperties.updated) {
            delete abstractProperties.updated;
        }
        return {
            key: keyItem,
            id: keyItem.kid,
            name: abstractProperties.name,
            properties: abstractProperties
        };
    }
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyProperties} based on a received KeyItem.
     */
    getKeyPropertiesFromKeyItem(keyItem) {
        const parsedId = parseKeyvaultIdentifier("keys", keyItem.kid);
        const attributes = keyItem.attributes || {};
        const resultObject = Object.assign(Object.assign(Object.assign({ createdOn: attributes.created, updatedOn: attributes.updated }, keyItem), parsedId), keyItem.attributes);
        delete resultObject.attributes;
        if (keyItem.attributes.expires) {
            resultObject.expiresOn = keyItem.attributes.expires;
            delete resultObject.expires;
        }
        return resultObject;
    }
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    createSpan(methodName, requestOptions) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
        span.setAttribute("az.namespace", "Microsoft.KeyVault");
        return span;
    }
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    setParentSpan(span, options = {}) {
        if (span.isRecording()) {
            const spanOptions = options.spanOptions || {};
            return Object.assign(Object.assign({}, options), { spanOptions: Object.assign(Object.assign({}, spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.KeyVault" }) }) });
        }
        else {
            return options;
        }
    }
}

exports.CryptographyClient = CryptographyClient;
exports.KeyClient = KeyClient;
exports.logger = logger;
//# sourceMappingURL=index.js.map
